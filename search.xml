<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fvilce%2F2019%2F09%2F28%2Fmain%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[PIP版本问题]]></title>
    <url>%2Fvilce%2F2019%2F06%2F11%2Fmain%2FPIP%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[提示错误： 这个错误，解决有三点：1、在shell中输入pip -V查看版本，却被告知是19.1.1的版本（错误） 2、输入python -m pip install –upgrade pip 升级，提示如下：（错误） 3、一大串红色字体（错误） 其实，此时升级的是pip，它提示的是pip3这个旧的版本。所以解决方法是：1、输入pip3 -V 可以看到提示的版本是9.0.1: 2、输入pip3 install –upgrade pip 可能会出现错误： 拒绝访问，无法进行旧版本的卸载更新，需要使用管理者身份重新进行更新。 3、输入pip3 -V进行检查 如果报错，在重新尝试，由于是国外网站，非常的慢，可能对网络延迟进行报错。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机搭建]]></title>
    <url>%2Fvilce%2F2018%2F12%2F11%2Fmain%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[远程虚拟机搭建一、创建虚拟机 使用VMware vSphere Client连接服务器，新建服务器，步骤如下：1、选用典型配置 2、命名 3、选用存储器 4、选择操作系统这里的系统应该和之后安装的镜像文件系统一致。 5、选用网卡这里创建两个网卡，一个vlan172用于外网可以上网，一个vlan51用于内网可以内部连接，但是每次只能使用一个网卡，所以需要根据需求切换。(这里使用两个网卡仅是因为学校内部ip分配的原因) 6、创建磁盘根据需求选择大小，后面也可以修改，这里选用Thin Provision并继续配置虚拟机基础设置。 7、虚拟机基础设置内存根据需求选择，也可以后面进行修改，CPU一样，这里选用基础的4核。在选用镜像时需要注意，这里选择的镜像文件是已经存放在服务器上的镜像文件，该方法不支持远程文件安装。勾选开启连接后，完成设置开启虚拟机后就可以自动安装了。 二、设置网络1、配置外网输入如下命令进入网卡配置路径下： 1234cd /etccd sysconfigcd network-scriptsls 可以看到有两个网卡，分别是ifcfg-ens192和ifcfg-ens224: 使用命令ip add查看网卡信息： 使用命令 1vi ifcfg-ens192 进入ifcfg-ens192文件中查看设置： 重要的是BOOTPROTO和ONBOOT两个设置，修改并配置静态ip如下： 保存退出后重启网卡并查询网卡信息： 12systemctl restart networkip add 测试外网的连接： 但是本机还是无法连接虚拟机。 2、配置内网进入外网网卡ifcfg-ens192中，将ONBOOT重新修改为no，关闭网卡，重启网卡。进入内网网卡ifcfg-ens224中，此时仅修改ONBOOT属性为yes，保存退出后重启网卡，这时候校园网会自动分配一个静态ip出来，如下： 随后重新进入网卡ifcfg-ens224进行配置如下： 保存退出后重启网卡，测试内网： 本地连接测试：]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无端]]></title>
    <url>%2Fvilce%2F2018%2F09%2F26%2Fsuibi%2F%E6%97%A0%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[无端游戏1、画一下进程五态图 进程(又称为进程实体)由三部分组成：PCB(进程控制块)、程序段和相关数据段 进程的基本状态和转换 1）三种基本状态及转换： a）就绪(Ready)状态：指进程已处于准备好运行的状态，及进程已经分配到需要的系统资源，只要在获得CPU就可以执行 b）执行(Running)状态：指进程获得了CPU正在执行，在单处理机系统中，最多只有一个进程处于该状态 c）堵塞(Block)状态：指正在执行的进程，在执行过程中发生了某时间(如：I/O请求、申请缓冲区失败等) 2）五种状态及转换： 为满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常再引入两种状态：创建和终止状态 2、Mysql有哪些锁，innodb使用行锁有什么限制条件MySQL的锁机制比较简单，最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁；BDB存储引擎采用的是页面锁，但也支持表级锁；InnoDB存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁。 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般 InnoDB锁 3、写一个SQL，查询选修多门课程的学生名字select 名字 from 表 group by 名字 having count(课程)&gt;1 4、讲一下TCP协议的三次握手三次握手和四次挥手 5、写一个算法，找出同父节点的两个节点的最远距离6、ArrayList和LinkedList分别是什么数据结构，为什么数组查询比链表快ArratList基础数据结构为数组，LinkedList基础数据结构为链表 数组的物理地址是递增的，而链表的物理地址不是，只能通过指针一个个的进行查询 7、HashMap原理讲一下，为什么要在75%的时候进行扩容为了散列均匀，防止过多的哈希冲突导致链表过长 8、SpringBoot简化了Spring的配置，但是SpringBoot使用哪些文件进行配置呢9、HashMap扩容机制（JDK1.7）扩容必须满足两个条件： 1）存放新值的时候当前已有元素的个数必须大于等于阈值 2）存放新值的时候当前存放数据发生hash冲突（当前key计算的hash值换算出来的数组下标位置已存在值） 因为这两个条件，所以存在下面这些情况： 1）hashmap在存值的时候(默认大小为16，负载因子0.75，阈值12)，可能达到最后存满16个值的时候，再存入第17个值才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash冲突 2）当然也有可能存储更多值(超过16个值，最多可以 存放26个值)都还没有扩容。原理：前11个值全部hash冲突，存到数组的同一个位置(这时元素个数小于阈值12，不会扩容)，后面所有存入的15个值全部分散到数组剩下的15个位置(这时元素个数大于等于阈值，但是每次存入的元素并没有发生hash冲突，所以不会扩容)，前面11+15=26，所以在存入第27个值的时候才同时满足上面两个条件，这时候才会发生扩容现象。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜马拉雅]]></title>
    <url>%2Fvilce%2F2018%2F09%2F21%2Fsuibi%2F%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%2F</url>
    <content type="text"><![CDATA[喜马拉雅 1、手撕快排2、Spring AOP机制Spring AOP机制其实就是“切面”技术，主要分为两大类：一个是动态代理技术，利用截取消息的方式对其进行装饰，以取代原有的对象行为；一个是静态织入技术，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。 Spring创建代理的规则为： 1）默认使用Java动态代理来创建AOP代理，这样就可以为任何实例创建代理了 2）当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB 3、讲讲动态代理、CGLIB代理Java动态代理： 利用的是jdk提供的API实现的，其中有两个很重要的类或接口。一个是InvocationHandler(interface)、另一个是Proxy(Class)。而每一个动态代理类都必须实现InvocationHandler接口，并且每个代理类的实例都关联到一个Handler，当我们通过代理对象调用一个方式的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用。我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作。这正是动态代理的优势，可以很方便的对代理类的函数进行统一的处理，而不是修改每个代理类中的方法。 CGLIB代理： jdk中的动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求为委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一个的局限性。 使用CGLIB实现动态代理，并不要求委托类必须实现接口，底层采用ASM字节码生成框架生成代理类的字节码。 创建代理对象的几个步骤： 生成代理类的二进制字节码文件 加载二进制字节码，生成Class对象（例如使用Class.forName()方法） 通过反射机制获得实例对象，并创建代理类对象 CGLIB在进行代理的时候进行的工作： 生成的代理类继承被代理类。这里需要注意：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理 代理类会为委托方法生成相应的两个方法，一个是重写的方法如sayHello方法，另一个是CGLIB$sayHello$0方法，我们可以看到它是直接调用父类的sayHello方法； 当执行代理对象的sayHello方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;，如果存在，则将调用MethodInterceptor中的intercept方法 代理方式 实现 优点 缺点 特点 JDK静态代理 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口 实现简单，容易理解 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 JDK动态代理 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 不需要硬编码接口，代码复用率高 只能够代理实现了接口的委托类 底层使用反射机制进行方法的调用 CGLIB动态代理 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 不能对final类以及final方法进行代理 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 4、Spring IOC原理IOC：控制反转也叫依赖注入，利用Java反射机制。所谓的控制反转是指本来被调用者的实例是有调用者来创建的。IOC是统一交给Spring来管理创建，将对象交给容器管理，你只需要在Spring配置文件总配置相应的bean，以及设置相关的属性，让Spring容器来生成类的实例对象以及管理对象。在Spring容器启动的时候，Spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 5、HashMap的实现原理，ConcurrentHashMap实现原理6、讲讲线程池7、synchronized和volatile8、手撕返回一个树的深度9、讲讲三次握手，http协议属于OSI哪层10、假如公司有一个庞大的电话号库，现在有一个电话号，如何快速定位查询公司库中是否有这个号码，设计一个存储结构或者使用哪种数据结构]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绿盟]]></title>
    <url>%2Fvilce%2F2018%2F09%2F19%2Fsuibi%2F%E7%BB%BF%E7%9B%9F%2F</url>
    <content type="text"><![CDATA[绿盟 1、SpringMVC和SpringBoot的区别2、Spring IOC原理3、讲讲继承和接口4、抽象类和接口的区别5、HashMap的实现原理，链表和红黑树的复杂度6、NIO和IO的区别，它的非堵塞原理]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人人网]]></title>
    <url>%2Fvilce%2F2018%2F09%2F18%2Fsuibi%2F%E4%BA%BA%E4%BA%BA%E7%BD%91%2F</url>
    <content type="text"><![CDATA[人人网 一面，手写代码，字符串回文判断，空格，标点符号不纳入计算，大小写字母忽略大小，求字母和数字是否构成回文。问题:项目中多线程怎么使用的。线程池中哪些地方是耗时操作，利用线程池的批处理中耗时的方面有哪些，分布式部署时如何监控摄像头信息，事务回滚的条件，手写jdbc事务回滚，对事务的理解，手写查询每门课的平均分，手写查询平均分大于80的课程.stringbuffer和stringbuilder的区别，后者不安全的原因是什么，分析一遍 二面，手写代码，两个二叉树合并，位置相同的且不为空计算两节点的和，存在为空的节点，则计算不为空的节点，构造一个新的二叉树出来。 问题:控制层的对象什么时候创建的，单例还是多例，默认是什么，equals和hashcode的区别，equals重写，hashcode不变会出现什么问题，举例分析，红黑树和平衡二叉树的区别，项目中的索引是怎么用的，有什么用，awk是什么，有什么用，三面:io多路复用，项目介绍，项目的实用性等等]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海康]]></title>
    <url>%2Fvilce%2F2018%2F09%2F17%2Fsuibi%2F%E6%B5%B7%E5%BA%B7%2F</url>
    <content type="text"><![CDATA[海康 1、接口是怎么发布的如何发布WebService接口 1) 编写服务代码 2) 发布WebService 3) 在Tomcat下创建Web应用 4) 复制axis相关的jar文件 5) 测试发布的WEB应用 6) 发布WebService 2、mybatis原理mybatis总结 3、多线程的原理，从多线程原理扯到了调度问题多线程总结 4、进程和线程区别线程进程 6、单核情况下多线程能否实现？原因单核与多核的区别在于任务的并行与并发进行。 并行：两件(多件)事情在同一时刻一起发生 并发：两件(多件)事情在同一时刻只能有一个发生，有CPU快速切换，从而给人的感觉是同时进行 使用多线程来实现并行计算来缩短计算时间时，只有在多核CPU下才行，单核CPU下启用多线程最终总的计算值是一样的，因为CPU在同一时间只能服务于一个线程。 7、jvm有哪些垃圾回收算法？垃圾回收算法 8、标记清除和标记整理有什么优缺点？原理说一下9、了解哪些容器？Java容器 10、你会哪些设计模式？讲一下你们项目用到了哪些设计模式？]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东方财富]]></title>
    <url>%2Fvilce%2F2018%2F09%2F16%2Fsuibi%2F%E4%B8%9C%E6%96%B9%E8%B4%A2%E5%AF%8C%2F</url>
    <content type="text"><![CDATA[东方财富 1、哪些排序是稳定的稳定排序：基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序 不稳定排序：快速排序、希尔排序、堆排序、直接选择排序 2、线程同步的几种方式多线程同步的几种方式 3、什么时候会导致垃圾回收失败可达性分析 在引用计数算法中，当a、b两个对象相互引用时，对导致他们的引用计数永远不可能为0。 可达对象：通过根对象的进行引用搜索，最终可以到达的对象 不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象 4、IO分为哪几种，分别讲一下IO与NIO的区别 IO：面向流、堵塞的 NIO：面向缓冲区、非堵塞的 JAVA NIO的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道；这些通道里已经有可以处理的输入，或者选择已准备写入的通道。 5、XML的几种解析XML的四种解析方式 DOM解析：即文档对象模型。基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序通过对这个对象模型的操作来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档的任何一部分数据，因此，这种利用DOM接口的机制也被称为随机访问机制。 SAX解析：即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称为时间驱动接口。 JDOM解析：Java特定的文档对象模型。自身不包含解析器，使用SAX DOM4J解析：采用Java集合框架，并完全支持DOM、SAX和JAXP 6、进程的几种通信方式进程间的五种通信方式 7、前端是如何调用接口的8、查询时，什么时候选树什么时候选哈希表B-树和Hash索引的区别 Hash索引检索效率高可以一次定位，不想B-Tree索引需要从根节点到枝节点，所以Hash索引的查询效率远高于B-Tree索引。但Hash索引不能使用范围查询，无法被用来避免数据的排序操作，不能利用部分索引键查询，任何时候都不能避免表扫描，并且Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 所以精准查询时可以选用哈希表，模糊查询时选用树。 9、讲讲ThreadLocalThreadLocal理解 ThreadLocal：线程的局部变量，是每一个线程所单独持有的，其他线程不能对其进行访问。 当然我们也可以使用volatile关键字来为此变量加锁，进行同步处理，从而限制只能有一个线程来使用此变量，但是加锁会大大影响执行效率。 10、Servlet、filter和Listener的区别JavaWeb三大组件 Servlet是用来处理客户端请求的动态资源，也就是当我们在浏览器中键入一个地址回车跳转后，请求就会被发送到对应的Servlet上进程处理。 Filter与Servlet在很多方面及其相似，但是也有不同，例如例如filter和servlet一样都又三个生命周期方法，同时他们在web.xml中的配置文件也是差不多的、 但是servlet主要负责处理请求，而filter主要负责拦截请求，和放行。 Listener就是监听器，我们在JavaSE开发或者Android开发时，经常会给按钮加监听器，当点击这个按钮就会触发监听事件，调用onClick方法，本质是方法回调。在JavaWeb的Listener也是这么个原理，但是它监听的内容不同，它可以监听Application、Session、Request对象，当这些对象发生变化就会调用对应的监听方法。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老虎证券]]></title>
    <url>%2Fvilce%2F2018%2F09%2F16%2Fsuibi%2F%E8%80%81%E8%99%8E%E8%AF%81%E5%88%B8%2F</url>
    <content type="text"><![CDATA[老虎证券： 1、hashmap手画2、volitile synchronize和lock3、设计模式4、gc算法5、分布式6、索引7、shell脚本8、手撕编程题3道1)实现一个缓存2)两个单链表合并为一个有序表3)实现一个洗牌算法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37互娱]]></title>
    <url>%2Fvilce%2F2018%2F09%2F15%2Fsuibi%2F37%E4%BA%92%E5%A8%B1%2F</url>
    <content type="text"><![CDATA[37互娱初面： 1、说一下Java的基础数据类型，其中Int占用多少字节，边界是多少整型：byte(1个字节) short(2个字节) int(4个字节) long(8个字节) 浮点型：float(4个字节) double(8个字节) 逻辑型：boolean 字符型：char(2个字节) int最小值为-2^31,最大值为2^31-1 2、为什么要用接口，直接实现不行吗通过接口实现多重继承 程序中的接口主要的作用就是进行功能的组合，使得同一个对象能够被使用在多种地方，其重大优势就是应对变化。接口是一种更高程度的抽象。接口一个大重要特征就是“职责单一”，接口是可选择的功能组合，而抽象只能是全盘接收，应对变化时，继承远不如接口灵活。 3、死锁产生的四个必要条件互斥条件：资源是单独占用且排他使用的 不可剥夺条件：进程所获得的资源在未使用完之前，不被其他进程强行剥夺 请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 产生死锁的原因主要是： 1）因为系统资源不足 2）进程进行推进的顺序不合适 3）资源分配不当等 死锁的避免与预防： 死锁避免的基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 死锁避免和死锁预防的区别：死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现，而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。 4、超时等待是什么原因超时等待：调用一个方法时，等待一段时间（一般给定一个时间段），如果该方法能够在给定的时间段内得到结果，那么将结果立刻返回，反之，超时返回默认结果。等待/通知的经典范式，即加锁，条件循环和处理逻辑三个步骤，而这种范式无法做到超时等待。 由于经典的等待/通知范式无法做到超时等待，也就是说，当消费者在获得锁后，如果条件不满足，等待生产者改变条件之前会一直处于等待状态，在一些实际应用中，会浪费资源，降低运行效率。事实上，只要对经典范式做出非常小的改动，就可以加入超时等待。 假设超时时间段是T，那么可以推断出，在当前时间now+T之后就会超时。 定义如下变量： 等待持续时间remaining = T； 超时时间future = now + T。 123456789long future = System.currentTimeMillis() + mills;long remaining = mills;synchronized (lock) &#123; while (!condition &amp;&amp; remaining &gt; 0) &#123; wait(remaining); remaining = future - System.currentTimeMillis(); &#125; //处理代码&#125; 5、Full gc在标记清除的时候是怎么标记的为了区分可用对象与垃圾对象，我们需要在每一个对象中记录对象的状态。我们在每一个对象中加入一个特殊的布尔类型的域，叫做marked。默认情况下，对象被创建时处于未标记状态。所以，marked域被初始化为false。对象p以及所有间接引用对象p的对象可以被下面的递归标记算法所标记。 6、讲讲红黑树的原理特性，红黑树比二叉平衡树好在哪，二叉平衡树的优点是什么红黑树： 1）节点是红色或黑色 2）根节点是黑色 3）每个叶子节点都是黑色的空节点（null节点） 4）每个红色节点的两个节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 红黑树并不是真正的平衡二叉树，但在实际应用中红黑树的统计性能要高于平衡二叉树，但极端性能略差。 7、写一个线程停止的程序出来如何正确地停止一个线程 8、cached和fixed的区别CachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。适用于生存期短、异步的线程任务 FixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 4种线程池 9、callable了解吗Callable和Runnable一样代表着任务，区别在于Callable有返回值并且可以抛出异常。 Future接口 Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。一旦计算完成了，那么这个计算就不能被取消。 FutureTask类 FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor 10、类加载过程java运行过程分为：编译–&gt;类加载–&gt;执行 类加载主要由jvm虚拟机负责的，过程非常复杂，类加载分为三步：加载–&gt;连接–&gt;初始化 1）加载：这个很简单，程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，用到的就是类加载器classLoader 2）连接：连接是很重要的一步，过程比较复杂，分为三步：验证–&gt;准备–&gt;解析 ​ 验证：确保类加载的正确性，是否符合jvm的编译规则，过滤掉不合法文件 ​ 准备：为类的静态变量分配内存，将其初始化为默认值 ​ 解析：把类中的符号引用转化为直接引用 3）初始化：为类的静态变量赋予正确的初始值(上面准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值) 11、异常种类，能不能抛error异常类分为两大类型：Error类代表了编译和系统错误，不允许捕获；Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。 运行异常类对应于编译错误，它是指Java程序在运行时产生的由解释器引发的各种异常。运行异常可能出现在任何地方，且出现频率很高，因此为了避免巨大的系统资源开销，编译器不对异常进行检查。所以Java语言中的运行异常不一定被捕获。出现运行错误往往表示代码有错误，如：算数异常（如被0除）、下标异常（如数组越界）等。 非运行异常时Non_RuntimeException类及其子类的实例，又称为可检测异常。Java编译器利用分析方法或构造方法中可能产生的结果来检测Java程序中是否含有检测异常的处理程序，对于每个可能的可检测异常，方法或构造方法的throws子句必须列出该异常对应的类。在Java的标准包java.lang java.util 和 java.net 中定义的异常都是非运行异常。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点整理(三)]]></title>
    <url>%2Fvilce%2F2018%2F09%2F12%2Fmain%2F%E4%B8%BB%E8%A6%81%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86%E7%82%B9(3)%2F</url>
    <content type="text"><![CDATA[主要详细知识点(3)二十五、常用算法考察 25.1 冒泡排序25.2 快速排序25.3 插入排序25.4 希尔排序25.5 归并排序25.6 堆排序25.7 桶排序25.8 动态规划25.9 最长公共子串25.10 最长回文子串25.11 数组的最大k个值25.12 数字的最大连续子数组之和25.13 左旋转字符串25.14 字符串匹配算法:KMP算法25.15 二分查找]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点整理(二)]]></title>
    <url>%2Fvilce%2F2018%2F08%2F27%2Fmain%2F%E4%B8%BB%E8%A6%81%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86%E7%82%B9(2)%2F</url>
    <content type="text"><![CDATA[主要详细知识点(2)二、链表 2.1 单链表逆序2.2 两个有序单链表合并2.3 两个单链表是否相交2.4 相交处的节点2.5 单链表倒数第K个数2.6 单链表排序三、栈和队列3.1 设计包含min函数的栈3.2 两个队列实现栈3.3 两个栈实现队列3.4 一个数组实现栈和队列四、树4.1 前序、中序、后序遍历4.2 求二叉树的深度4.3 按层次遍历二叉树4.4 判断二叉树是否为完全二叉树4.5 判断二叉树是否镜面对称4.6 判断两颗树是否相等五、卡特兰数5.1 出栈顺序5.2 n个节点构成的二叉树个数括号化 凸多边形三角划分 六、设计模式Java源码中有哪些设计模式 常见的设计模式类图 常见的设计模式的示例 七、数据库数据库引擎 数据库的crud语句的书写 数据库优化策略、如何优化 海量数据优化 事务 事务中锁分类 临时表 索引 存储空间 视图 八、Linux常用命令（最好实战）http://www.php100.com/html/webkaifa/Linux/2009/1106/3485.html 九、linux上搭建服务器http://www.cnblogs.com/dudu/archive/2012/12/09/linux-apache-git.html 十、常用的网络端口http://www.360doc.com/content/11/1202/09/8209768_169068538.shtml 十一、Nosql、redis等的熟悉、了解http://www.yiibai.com/redis/redis_quick_guide.html 十二、海量数据的处理Bit-map、分而治之、hash映射、分布式处理（Hadoop）、Trie树、双层桶排序等 十三、JVM内存管理和存储机制http://blog.csdn.net/lengyuhong/article/details/5953544 十四、JVM垃圾回收机制，垃圾回收算法http://jbutton.iteye.com/blog/1569746 十五、JVM加载类过程 http://www.cnblogs.com/sunada2005/p/3577799.html 十六、JVM内存调优http://www.cnblogs.com/jackyrong/archive/2010/01/21/1653163.html http://blog.csdn.net/cutesource/article/details/5907418 十七、框架相关对框架的熟悉:SSH （面试过程中问的很少，像jsp、servlet基本不问） Spring框架组成、AOP、IOC 、用到的设计模式 Hibernate运行机制、缓存的使用、最好看看源码 熟悉和了解JavaScript和jQuery 十八、java中IO、NIOJava NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 IO流包括字节流和字符流： 字节流：对应抽象类为InputStream（输入流）和 OutputStream（输出流）。 FileInputStream、FileOutputStream 字符流：对应抽象类为Reader（输入流）和Writer（输出流）。BufferedReader、InputStreamReader、 StringReader 十九、java中异常的分类及结构Java中的异常类，包括内置的异常类以及自定义的异常类，都直接或者间接地继承至java.lang.Throwable类。在java.lang包中，Throwable类有两个直接子类：Error类和Exception类，Error类及其子类描述了java运行时系统的内部错误和资源耗尽错误。出现这样的错误的，除了通知用户，并接尽力使程序安全地终止之外，没有更好的办法。Exception类的层次结构又分为两个分支：一个分支由RuntimeException派生，另外一个分支包含除RuntimeException类之外的异常类。 二十、运行时异常、非运行时异常运行时异常：RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException、classCastException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，不处理程序不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。 二十一、动态代理机制动态代理可以提供对另一个对象的访问，同时隐藏实际对象的具体事实。代理一般会实现它所表示的实际对象的接口。代理可以访问实际对象，但是延迟实现实际对象的部分功能，实际对象实现系统的实际功能，代理对象对客户隐藏了实际对象。客户不知道它是与代理打交道还是与实际对象打交道。动态代理主要包含以下角色：动态代理类（以下简称为代理类）是一个实现在创建类时在运行时指定的接口列表的类，该类具有下面描述的行为。代理接口 是代理类实现的一个接口。代理实例 是代理类的一个实例。每个代理实例都有一个关联的调用处理程序 对象，它可以实现接口 InvocationHandler。通过其中一个代理接口的代理实例上的方法调用将被指派到实例的调用处理程序的 Invoke 方法，并传递代理实例、识别调用方法的java.lang.reflect.Method 对象以及包含参数的 Object 类型的数组。调用处理程序以适当的方式处理编码的方法调用，并且它返回的结果将作为代理实例上方法调用的结果返回。 二十二、try catch finally的使用\1. finally 里 始终会被执行到， System.exit(0); 除这种被执行外。\2. 即使try中有return ，也是先执行 return 后面的语句完了之后，不立马return，而是去执行finally中的语句。 \3. 当try中与finally里，同时出现return , 则只会返回 finally 中的return 结果。\4. finally中的值不能影响try中 即将返回的结果值。注意： 若finally中没有return在try或catch中有return，那么在执行return跟着语句之后，会把语句的结果新开辟一内存空间，直接把结果的存放此内存空间中。所以，finally中的值不能影响try或catch中即将return的结果。 二十三、静态成员、非静态成员（1）类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。 （2）在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错 二十四、抽象类遵循的原则：（1）abstract关键字只能修饰类和方法，不能修饰字段。 （2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。 （3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化、不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。 （4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。 （5）含有抽象方法的类必须定义成抽象类。 扩展：抽象类和接口的区别： （1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。 （2）abstractclass 在Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。 （3）在abstractclass 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。 （4）abstractclass和interface所反映出的设计理念不同。其实abstractclass表示的是”is-a”关系，interface表示的是”has-a”关系。 （5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。 （6）接口中定义的变量默认是publicstatic final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2Fvilce%2F2018%2F08%2F01%2Fmain%2FSpring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%97%B6%E8%87%AA%E6%88%91%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring事务处理时自我调用一. AOP概念 面向方面编程(AOP)：也可称为面向切面编程，是一种编程范式，提供从另一个角度来考虑程序结构从而完善面向对象编程(OOP)。AOP主要是用于进行横切关注点分离和织入。 (1)AOP的基本概念： 连接点（Jointpoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为“在哪里干”； 切入点（Pointcut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在哪里干的集合”； 通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”； 方面/切面（Aspect）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”； 引入（inter-type declaration）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“干什么（引入什么）”； 目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁干”； AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。 织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。 (2)AOP代理就是AOP框架通过代理模式创建的对象 AOP代理的目的就是将切面织入到目标对象 补充：代理模式代理模式的关键点是：代理对象与目标对象，代理对象是对目标对象的扩展，并会调用目标对象 1. 静态代理静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类.。 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类,类太多。同时，一旦接口增加方法，目标对象与代理对象都要维护。 2. 动态代理动态代理有以下特点： 代理对象不需要实现接口 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 动态代理也叫做JDK代理，接口代理 代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理 3. Cglib代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候就可以使用以目标对象子类的方式类实现代理，这种方法就叫做:Cglib代理 Cglib代理也叫子类代理，它是在内存中构建一个子类对象从而实现对目标对象的扩展 二. Spring的事务管理事务有四个特性：ACID 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 Spring事务管理涉及的接口的联系如下： Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 编程式事务：所谓编程式事务指的是通过编程方式实现事务，即类似于JDBC编程实现事务管理 编程式和声明式事务的区别：Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务(基于AOP)有助于用户将操作与事务规则进行解耦。简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起来事务管理的作用，又可以不影响业务代码的具体实现。 Spring中的事务分为物理事务和逻辑事务： 物理事务：就是底层数据库提供的事务支持，如JDBC或JTA提供的事务 逻辑事务：是Spring管理的事务，不同于物理事务，逻辑事务提供更丰富的控制，而且如果想得到Spring事务管理的好处，必须使用逻辑事务，因此在Spring中如果没特别强调一般就是逻辑事务 三. AOP代理后方法调用 首先调用的是AOP代理对象而不是目标对象，首先执行事务切面，事务切面内部通过TransactionInterceptor 环绕增强进行事务的增强，即进入目标方法之前开启事务，退出目标方法时提交/回滚事务。 1. 测试目标对象有两个方法a、b，a调用了b 123456789101112131415public interface AService &#123; public void a(); public void b();&#125; @Service()public class AServiceImpl1 implements AService&#123; @Transactional(propagation = Propagation.REQUIRED) public void a() &#123; this.b(); &#125; @Transactional(propagation = Propagation.REQUIRES_NEW) public void b() &#123; &#125;&#125; 2. 问题目标对象内部的自我调用将无法实施切面中的增强，如图所示： 此处的this指向目标对象，因此调用this.b()将不会执行b事务切面，即不会执行事务增强，因此b方法的事务定义“@Transactional(propagation = Propagation.REQUIRES_NEW) ”将不会实施，即结果是b和a方式的事务定义是一样的。查看日志看出： 1234567891011121314151617181920212223242526272829303132333435363738394041org.springframework.transaction.annotation.AnnotationTransactionAttributeSource Adding transactional method &apos;a&apos; with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos;org.springframework.beans.factory.support.DefaultListableBeanFactory Returning cached instance of singleton bean &apos;txManager&apos;org.springframework.orm.hibernate4.HibernateTransactionManager Creating new transaction with name [com.sishuok.service.impl.AServiceImpl1.a]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; &apos;&apos; -----创建a方法事务org.springframework.orm.hibernate4.HibernateTransactionManager Opened new Session …… for Hibernate transaction ---打开Session……org.springframework.transaction.support.TransactionSynchronizationManager Initializing transaction synchronizationorg.springframework.transaction.interceptor.TransactionInterceptor Getting transaction for [com.sishuok.service.impl.AServiceImpl1.a]org.springframework.transaction.interceptor.TransactionInterceptor Completing transaction for [com.sishuok.service.impl.AServiceImpl1.a] ----完成a方法事务org.springframework.orm.hibernate4.HibernateTransactionManager Triggering beforeCommit synchronizationorg.springframework.orm.hibernate4.HibernateTransactionManager Triggering beforeCompletion synchronizationorg.springframework.orm.hibernate4.HibernateTransactionManager Initiating transaction commit org.springframework.orm.hibernate4.HibernateTransactionManager Committing Hibernate transaction on Session ……---提交a方法事务或org.springframework.orm.hibernate4.HibernateTransactionManager Rolling back Hibernate transaction on Session ……---如果有异常将回滚a方法事务 org.springframework.orm.hibernate4.HibernateTransactionManager Triggering afterCommit synchronizationorg.springframework.orm.hibernate4.HibernateTransactionManager Triggering afterCompletion synchronizationorg.springframework.transaction.support.TransactionSynchronizationManager Clearing transaction synchronization……org.springframework.orm.hibernate4.HibernateTransactionManager Closing Hibernate Session …… after transaction --关闭Session 可以看出事务切面只对a方法进行了事务增强，没有对b方法进行增强。 3. 解决方案此处a方法中调用b方法时，只要通过AOP代理调用b方法即可走事务切面，即可以进行事务增强： 123public void a() &#123; aopProxy.b();//即调用AOP代理对象的b方法即可执行事务切面进行事务增强&#125; 判断一个Bean是否是AOP代理对象可以使用如下三种方法： AopUtils.isAopProxy(bean) ： 是否是代理对象； AopUtils.isCglibProxy(bean) ： 是否是CGLIB方式的代理对象； AopUtils.isJdkDynamicProxy(bean) ： 是否是JDK动态代理方式的代理对象； 3.1 通过ThreadLocal暴露AOP代理对象开启暴露AOP代理到ThreadLocal支持(如下配置方式从Spring3开始支持) 12&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;&lt;!—注解风格支持--&gt; &lt;aop:config expose-proxy=&quot;true&quot;&gt;&lt;!—xml风格支持--&gt; 修改业务实现类 this.b();———–修改为———&gt;((AService) AopContext.currentProxy()).b(); 3.2 实现原理分析 在进入代理对象之后通过AopContext.serCurrentProxy(proxy)暴露当前代理对象到ThreadLocal，并保存上次ThreadLocal绑定的代理对象为oldProxy； 接下来我们可以通过 AopContext.currentProxy() 获取当前代理对象； 在退出代理对象之前要重新将ThreadLocal绑定的代理对象设置为上一次的代理对象，即AopContext.serCurrentProxy(oldProxy)。 有些人不喜欢这种方式，说通过ThreadLoad暴露有性能问题，其实这个不需要考虑，因为事务相关的(Session和Connection)内部也是通过SessionHolder和ConnectionHolder暴露到ThreadLoad实现的。 3.3 通过初始化方法在目标对象中注入代理对象1234567891011121314151617181920@Servicepublic class AServiceImpl3 implements AService&#123; @Autowired //① 注入上下文 private ApplicationContext context; private AService proxySelf; //② 表示代理对象，不是目标对象 @PostConstruct //③ 初始化方法 private void setSelf() &#123; //从上下文获取代理对象（如果通过proxtSelf=this是不对的，this是目标对象） //此种方法不适合于prototype Bean，因为每次getBean返回一个新的Bean proxySelf = context.getBean(AService.class); &#125; @Transactional(propagation = Propagation.REQUIRED) public void a() &#123; proxySelf.b(); //④ 调用代理对象的方法 这样可以执行事务切面 &#125; @Transactional(propagation = Propagation.REQUIRES_NEW) public void b() &#123; &#125;&#125; 和3.1类似，方式不是很灵活，所有需要自我调用的实现类必须重复实现代码。 3.4 通过BeanPostProcessor在目标对象中注入代理对象略 四. 总结纵观其上： 【3.1 通过ThreadLocal暴露Aop代理对象】适合解决所有场景（不管是singleton Bean还是prototype Bean）的AOP代理获取问题（即能解决目标对象的自我调用问题）； 【3.2 通过初始化方法在目标对象中注入代理对象】 和【3.4 改进版的InjectBeanSelfProcessor的解决方案】能解决普通（无循环依赖）的AOP代理对象注入问题，而且也能解决【3.3】中提到的循环依赖（应该是singleton之间的循环依赖）造成的目标对象无法注入AOP代理对象问题，但该解决方案不适合解决循环依赖中包含prototype Bean的自我调用问题； 【3.3 通过BeanPostProcessor 在目标对象中注入代理对象】：只能解决 普通（无循环依赖）的 的Bean注入AOP代理，无法解决循环依赖的AOP代理对象注入问题，即无法解决目标对象的自我调用问题。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里]]></title>
    <url>%2Fvilce%2F2018%2F07%2F22%2Fsuibi%2F%E9%98%BF%E9%87%8C%2F</url>
    <content type="text"><![CDATA[阿里初面：1. AOP实现原理 AOP原理分析 AOP技术利用“横切”技术，破解开封装的对象内部，将影响多个类的公共行为封装到一个可重用模块，名为“Aspect”，即方面。使用“横向”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离” 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码 2. SpringBoot和Spring的区别SpringBoot实现了自动配置，降低了项目搭建的复杂度。集成了大量常用的第三方库配置，内嵌tomcat。 Spring是一个“引擎”，SpringMVC是基于Spring的一个MVC框架，SpringBoot是基于Spring4的条件注册的一套快速开发整合包 Spring Boot可以建立独立的Spring应用程序 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了 无需再像Spring那样弄一堆繁琐的xml文件的配置 可以自动配置Spring 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能 提供的POM可以简化Maven的配置 3. SpringBoot的启动流程SpringBoot启动原理 SpringBoot启动结构图 启动类启动 可以发现一个Annotation定义(@SpringBootApplication)和类定义(SpringApplication.run) 查看注解SpringBootApplication使用了多个Annotation进行了信息标注，但实际上重要的只有三个： @Configuration（@SpringBootConfiguration点开查看后发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan 可以将@SpringBootApplication替换为这三个进行启动，发现其功能时对等的。 @Configuration 就是JavaConfig形式的Spring IOC容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IOC容器的配置类。 任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。 @ComponentScan 对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。 我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。 1注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。 所以SpringBoot主配置类只会扫描自己所在的包及其子包下面 @EnableAutoConfiguration 最关键的是 1@Import(EnableAutoConfigurationImportSelector.class) 借助@Import的帮助，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration才可以智能的自动配置 从classpath中搜索所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射(Java Refletion)实例化为对应的标注了@Configuration的JavaConfig形式的IOC容器配置类，然后汇总为一个并加载到IOC容器。 深入探索SpringApplication执行流程 SpringApplication的run方法的实现主要流程： 1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情： 根据classpath里面是否存在某个特征类(org.springframework.web.context.ConfigurableWebApplicationContext)来决定是否应该创建一个为Web应用使用的ApplicationContext类型。 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。 推断并设置main方法的定义类。 2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。 3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。 4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。 5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。 6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。 7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。 8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。 9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。 11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。 12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）去除事件通知点后，整个流程如下： 4. SpringBoot内嵌tomact是如何运行的使用tomcat时需要配置环境，在SpringBoot中，tomcat被内嵌在项目中，并不需要再去配置环境变量 1). 初始化Tomcat，并且给分配端口号(8066) 2). 启动Tomcat 3). 启动Tomcat引擎(显示tomcat版本，SpringBoot1.5.9内嵌的是tomcat/8.5.23) 4). SpringBoot项目前期环境准备完成，初始化SpringWeb内嵌的上下文容器 5). RootWebSpring上下文初始化完成 5. SpringBoot如何整合第三方框架，start是如何启动的6. 多线程的死锁是什么原理，死锁时多线程处于什么状态所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局 (1)竞争资源 (2)进程间推进顺序非法（进程在运行中具有异步性） 死锁时多线程等待资源的释放，处于等待状态 7. 阻塞和等待有什么区别，举一个场景解释一下 阻塞：当一个线程试图获取一个内部的对象锁(非java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进入阻塞状态 等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。例如调用：Object.wait()、Thread.join()以及等待Lock或Condition 两者都表示线程当前暂停执行的状态，而两者的区别，基本可以理解为：进入 waiting 状态是线程主动的，而进入 blocked 状态是被动的。更进一步的说，进入 blocked 状态是在同步（synchronized）代码之外，而进入 waiting 状态是在同步代码之内（然后马上退出同步）。 1234567891011//验证阻塞try&#123; // 等待主线程获取锁 Thread.sleep(10000); // 请求locker对象的内部锁 synchronized (locker) &#123; System.out.println(&quot;Get locker&quot;); &#125;&#125; catch (InterruptedException e) &#123; // TODO: handle exception&#125; 123456789//验证等待try&#123; synchronized (locker) &#123; System.out.println(&quot;wait locker&quot;); locker.wait(); &#125;&#125;catch (InterruptedException e) &#123; // TODO: handle exception&#125; 8. Mysql索引，复合索引等是怎么回事索引是对数据库表中一列或多列的值进行排序的一种结构。例如employee表的姓(name)列，如果要按姓查找特定职员，与必须搜索表中的所有行相比，索引会帮助您更快地获得该信息。 复合索引是指一个索引包含多个字段(表列)，比如index d1(s1)是单一索引，index d2(s1,s2)就是复合索引，复合索引中的第一个字段称为主索引码，决定了索引b树的结构 索引原理 9. 了解Redis集群吗，介绍一下10. Spring与mybatis是怎么实现执行sql语句的11. 讲一下设计的表结构12. spring aop的实现方法。如果aop配置了两个方法a、b，a调用了b拦截之后有几个日志AOP常用的实现方式有两种，一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ）。 AOP中的重要概念： Joinpoint(连接点)：程序执行时的某个特定的点，在Spring中就是某一个方法的执行 Pointcut(切点)：说的通俗点，spring中AOP的切点就是指一些方法的集合，而这些方法是需要被增强、被代理的。一般都是按照一定的约定规则来表示的，如正则表达式等。切点是由一类连接点组成。 Advice(通知)：就是指定切点上要做些什么 Advisor(通知器)：其实就是切点和通知的结合 一、基于XML配置的Spring AOP 采用声明的方式实现(在XML文件中配置)，大致步骤为：配置文件中配置pointcut，在java中用编写实际的aspect类，针对对切入点进行相关的业务处理。 二、使用注解配置AOP 采用注解来做AOP，主要是将写在Spring配置文件中的连接点写到注解里面。 Spring AOP中自我调用的问题 在使用AOP进行拦截的时候发现有哪些方法有时候能输出拦截的日志有时候不输出拦截的日志。发现在单独调用这些方法的时候是有日志输出的，在被同一类中的方法调用的时候没有日志输出。 现象描述：假设有一个service，其中有A B 两个方法，A B都被aop托管，且A中调用了B方法，这时请求方法A的时候只会触发A的aop逻辑而不会触发B的aop逻辑。 假设有一个类是ServiceA，这个类中有一个A方法，A方法中又调用了B方法。当我们使用AOP进行拦截的时候，首先会创建一个ServiceA的代理类，其实在我们的系统中是存在两个ServiceA的对象的，一个是目标ServiceA对象，一个是生成的代理ServiceA对象，如果在代理类的A方法中调用代理类的B方法，这个时候AOP拦截是可以生效的，但是如果在代理类的A方法中调用目标类B方法，这个时候AOP拦截是不生效的，大多数情况下我们都是在代理类的A方法中直接调用目标类的B方法。 13. AOP的两种实现spring aop和aspectJ的具体区别是什么AspectJ AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。 Spring AOP Spring提供了四种类型的Aop支持 基于经典的SpringAOP 纯POJO切面 @ASpectJ注解驱动的切面 注入式AspectJ切面（其实与Spring并无多大的关系，这个就是使用AspectJ这个框架实现Aop编程） Spring AOP不同于大多数其他AOP框架。Spring AOP的目的并不是为了提供最完整的AOP实现(虽然Sping AOP具有相当的能力)；而是为了要帮助解决企业应用中常见问题，提供一个AOP实现与Spring IOC之间的紧密集成。由于Spring AOP是容易实现的，如果你计划在Spring Beans之上将横切关注点模块化，Spring的这一目标将是要点之一。但同样的目标也可能成为一个限制，如果你用的是普通的Java对象而不是Spring Beans，并基于此将关注点模块化的话。另一方面，AspectJ可用于基于普通Java对象的模块化，但在实施之前需要良好的关于这个主题的知识。 Spring AOP致力于提供一种能够与Spring IoC紧密集成的面向方面框架的实现，以便于解决在开发企业级项目时面临的常见问题。明确你在应用横切关注点(cross-cutting concern)时（例如事物管理、日志或性能评估），需要处理的是Spring beans还是POJO。如果正在开发新的应用，则选择Spring AOP就没有什么阻力。但是如果你正在维护一个现有的应用（该应用并没有使用Spring框架），AspectJ就将是一个自然的选择了。为了详细说明这一点，假如你正在使用Spring AOP，当你想将日志功能作为一个通知(advice)加入到你的应用中，用于追踪程序流程，那么该通知(Advice)就只能应用在Spring beans的连接点(Joinpoint)之上。 14. spring aop实现的限制AOP下的权限控制实现 15. hashmap的具体实现16. hashcode与equal的关系Java对于eqauls方法和hashCode方法是这样规定的： (1)同一对象上多次调用hashCode()方法，总是返回相同的整型值。 (2)如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。 (3)如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 (4)a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 (5)a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。2、如果两个对象不equals，他们的hashcode有可能相等。3、如果两个对象hashcode相等，他们不一定equals。4、如果两个对象hashcode不相等，他们一定不equals 17. mongoDB与mysql的区别，是不是mongoDB只用设计一张表就行了，相对mysql优化了哪些18. 了解了什么web技术]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java开发面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点整理(一)]]></title>
    <url>%2Fvilce%2F2018%2F07%2F19%2Fmain%2F%E4%B8%BB%E8%A6%81%E8%AF%A6%E7%BB%86%E7%9F%A5%E8%AF%86%E7%82%B9(1)%2F</url>
    <content type="text"><![CDATA[主要详细知识点(一)一、Java基础 1.1 HashMap的存储机制（很重要，必看）HashMap实现原理分析及简单实现 HashMap是基于哈希表的Map接口的非同步实现。 HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 对于HashMape而言，系统将key-value当成一个整体进行处理，系统根据Hash算法来计算key-value的存储位置，这样可以保证快速存取Map的key-value对。Entry就是数组中的元素 ，Map.Entry其实就是一个key-value对,系统在存储key-value对时，仅仅只是根据key来计算并决定每个Entry的存储位置。 “Hash算法”：每个Java对象都有hashCode()方法，都可通过该方法获得它的hashCode值，系统根据该hashCode值来决定该元素的存储位置。 HashMap初始容量为16，负载因子为0.75，当HashMap中元素个数超过16*0.75=12的时候，数据大小扩展为32，然后重新计算每个元素的位置，非常消耗性能操作，所以需要我们预知元素个数，预设元素个数提高性能。 扩充： HashMap和HashTable的区别： (1)继承父类不同，HashMap继承自AbstractMap，而HashTable继承自Dictionary类 (2)对外提供接口不同，HashTable比HashMap多提供了elments()和contains()两个方法 (3)对Null key和Null value的支持不同，HashTable既不支持Null key也不支持Null value (4)线程安全性不同，HashTable是线程安全的，而HashMap不是 (5)遍历方式不同，初始容量大小和每次扩充容量大小不同 (6)计算Hash值的方法不同 1.2 Set、map区别(1)set的节点是一个数据，map的节点是一对键值对 (2)map使用关键值key来唯一标识每一个成员，map的value值可以重复；set存储的无重复的元素 (3)set是conllection接口的子接口，map不是conllection的子接口或实现类，map是一个接口 1.3 Set、list区别(1)set、list都是collection接口的子接口 (2)list可以允许重复的对象，可以插入多个null元素；set不允许重复对象，只允许一个null元素 (3)list是一个有序容器，保持了每个元素的插入顺序，输出顺序就是插入顺序；set是无序容器，无法保证每个元素的存储顺序，TreeSet通过Comparator或者Comparable维护了一个排序顺序。 1.4 ArrayList、LinkedList区别(1)ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构 (2)对于随意访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针 (3)对于新增和删除操作add和remove，LinkedList比较占优势，因为ArratList要移动数据 补充： Vector：类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的 1.5 String、StringBuffer、StringBuilder区别(1)在运行速度上：StringBuilder&gt;StringBuffer&gt;String String是字符串常量，而StringBuilder和StringBuffer是字符串变量，即String对象一旦创建后是不可更改的 (2)在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果要进行多线程操作，就要使用StringBuffer，在单线程情况下，使用速度较快的StringBuilder (3)String：适用于少量字符串操作的情况 ​ StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 ​ StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 1.6 HashSet、TreeSet、LinkedHashSet区别(1)HashSet：不能保证元素的排列顺序，顺序有可能发生变化，且是不同步的，集合元素可以是null但只能放入一个null（和HashMap实现的接口规范不同，但底层的Hash存储机制完全一样） (2)TreeSet：是J2SE中唯一可实现自动排序的类型，是SortedSet接口的唯一实现类，集合元素处于排序状态。支持自然排序和定制排序（通过红黑树实现） (3)LinkedHashSet：根据元素的HashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序。在访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet 1.7 HashMap、TreeMap、LinkedHashMap(1)HashMap：根据键的HashCode值存储数据，遍历时，取得数据的顺序是完全随机的，具有很快的访问速度；最多只允许一条记录的键为null，允许多条记录的值为null；不支持线程同步（通过哈希表实现） (2)TreeMap：将保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器（通过红黑树实现） (3)LinkedHashMap：保存了记录的插入顺序，在遍历的时候会比HashMap慢，但当HashMap容量很大，实际数据较少时，遍历起来可能比LinkedHashMap慢 1.8 熟悉Java集合类的框架图 1.9 HashMap、ArrayList、StringBuffer、String等源码的熟悉HashMap、ArrayList源码分析 StringBuffer、String源码分析 1.10 线程和进程定义：进程时操作系统分配资源的最小单元，线程时操作系统调度的最小单元 关系：一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行 (1)一个程序至少有一个进程，一个进程至少有一个线程 (2)线程的划分尺度小于进程，使得多线程程序的并发性高 (3)进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 (4)线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 (5)从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配 优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 1.11 线程的特性原子性：操作是单一不可分割的操作 内存可见性：cpu在执行代码时，为了减少变量访问的时间消耗可能会将变量的值缓存到该cpu的缓存区。因此在再次访问该变量时可能会从cpu缓存而不是主内存中读取的。同样的，对变量的修改等操作也会写入cpu缓存区，而没有写回主内存。cpu的缓存区对其他cpu而言是不可见的，这就导致了其他cpu上的线程可能无法看到该线程对某变量的更改，这就是内存可见性 重排序：编译器和cpu为了提高指令的执行效率可能会进行指令重排序。使得代码的实际的执行方式可能不是按照我们认为的方式进行的。如一个对象的初始化，可能会先为该实例引用创建内存空间并且创建引用，而不是先去初始化某个实例对象 1.12 线程的状态(1) 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 (2) 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的成为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得cpu 时间片后变为运行中状态（running）。 (3)阻塞(BLOCKED)：表线程阻塞于锁。 (4)等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 (5)超时等待(TIME_WAITING)：该状态不同于WAITING，它可以在指定的时间内自行返回。 (6) 终止(TERMINATED)：表示该线程已经执行完毕。 1.13 多线程并发的实现区分线程和进程，通常一个程序有一个进程，而一个进程可以有多个线程。一个任务不一定对应一个线程可能是多个线程或是一个线程池 区分并发和并行，并发是指在一段时间内同时做多个事情，而并行是指在同一时刻做多个事情。并发就是在单核处理中同时处理多个任务(这里的同时指的是逻辑上的同时)，并行就是在多核处理器中同时处理多个任务(这里的同时指的是物理上的同时) CPU采用时间片轮转等不同算法来对线程进行调度，从而实现多线程的并发 1.14 线程的创建方式(1)继承Thread类创建线程：定义Thread类的子类，并重写该类的run()方法。创建Thread子类的实例，也就是创建了线程对象；启动线程即调用线程的start()方法 (2)实现Runnable接口创建线程：定义Runnable接口的实现类，一样重写run()方法；创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个对象才是真正的线程对象；依然用start()启动 (3)使用Callable和Future创建线程：创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例；使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值；使用FutureTask对象作为Thread对象的target创建并启动线程；调用FuntureTask对象的get()方法来获得子线程执行结束后的返回值 1.15 线程池的使用线程池的使用 优势：提高了系统的效率。线程执行完一个任务并不被销毁而是可以继续执行其他的任务 1.16 Java作用域 作用域、可见性 同类 同包 子类 其他包 public 可见 可见 可见 可见 private 可见 不可见 不可见 不可见 protected 可见 可见 可见 不可见 default 可见 可见 不可见 不可见 1.17 final、static、native等特殊关键字的使用static &amp; final &amp; native 1.18 Java按值传递的过程 按值传递：指的是在方法调用时，传递的参数是按值得拷贝传递 ​ 特点：传递的是值的拷贝，也就是说传递后就互不相关了 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址 特点：传递的是值的引用，也就是说传递前后都指向同一个引用 (1)”在Java里面参数传递都是按值传递”：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递 (2)在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java” 1.19 重写、重构和重载方法重载：指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数 方法重写：为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明为虚拟的，这需要在改成员的返回类型之前添加virtual关键字。然后子类使用override关键字，将父类的实现，替换为自己的实现 (继承是原封不动的，全部照搬，无法体现多样性。即当针对父类的方法，在子类中需要有些修改的时候，就需要使用方法重写) 重构：就是通过调整程序代码改软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性 1.20 抽象类和接口深入理解抽象类和接口 1.21 内部类的使用：匿名内部类、静态内部类等Java中的内部类 1.22 Java多线程并发、生产者消费者的实现Java多线程之并发协作生产者消费者设计模式 1.23 Java连接数据库的过程JDBC是数据库连接的一套API，DBCP是一个常用的数据库连接池 连接数据库步骤 补充1. 九种基本数据类型的大小，以及他们的封装类基本数据类型： boolean, byte, char, short, int, long, float, double, void. 封装类： Boolean, Byte, Character, Short, Integer, Long, Float, Double, Void 区别： 基本数据类型只能按值传递，而封装类按引用传递 基本类型在堆栈中创建；而对于对象类型，对象在堆中创建，对象的引用在堆栈中创建。基本类型由于在堆栈中，效率会比较高，但是可能会存在内存泄漏的问题 2. Switch能否用String做参数在Java7之前无法使用字符串，只能支持byte、short、char、int这几个基本数据类型和其对应的封装类型。Java7以及以后的版本中可以使用字符串，查看源码后可以发现，其实Switch实现对String的操作，主要是对其做了一次hashCode()，而且hashCode()正好返回的是int. 3. equals与==的区别equals：用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断 ==：比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作 4. Object有哪些公用方法clone：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常 equals：在Object中与==是一样的，子类一般需要重写该方法 hashCode：该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到 getClass：final方法，获得运行时类型 wait：使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 notify：唤醒在该对象上等待的某个线程 notifyAll：唤醒在该对象上等待的所有线程 toStrng：转换成字符串，一般子类都有重写，否则打印句柄 5. Java的四种引用，强弱软虚，用到的场景强引用：以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题 例如： 12Object obj = new Object()//可直接通过obj取得对应的对象 如obj.equels(new Object()); obj对象对后面new Object的一个强引用，只有当obj这个引用被释放掉，对象才会被释放掉 软引用：如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 例如： 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 弱引用：如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 例如： 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 虚引用：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 例如： 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。 虚引用主要用于检测对象是否已经从内存中删除。 6. Map、Set、List、Queue、Stack的特点与用法 Map Map是键值对，键Key是唯一不能重复的，一个键对应一个值，值可以重复。 TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。 Map中可以将Key和Value单独抽取出来，其中KeySet()方法可以将所有的keys抽取正一个Set。而Values()方法可以将map中所有的values抽取成一个集合。 Set 不包含重复元素的集合，set中最多包含一个null元素 只能用Lterator实现单项遍历，Set中没有同步方法。 List 有序的可重复集合。可以在任意位置增加删除元素。用Iterator实现单向遍历，也可用ListIterator实现双向遍历 Queue Queue遵从先进先出原则。使用时尽量避免add()和remove()方法,而是使用offer()来添加元素，使用poll()来移除元素，它的优点是可以通过返回值来判断是否成功。LinkedList实现了Queue接口。Queue通常不允许插入null元素。 Stack Stack遵从后进先出原则。Stack继承自Vector。它通过五个操作对类Vector进行扩展，允许将向量视为堆栈，它提供了通常的push和pop操作，以及取堆栈顶点的peek()方法、测试堆栈是否为空的empty方法等 用法 如果涉及堆栈，队列等操作，建议使用List对于快速插入和删除元素的，建议使用LinkedList如果需要快速随机访问元素的，建议使用ArrayList 7. Collection包结构与Collections的区别Collection是集合类的上级接口，继承与他相关的接口主要有List和Set Collections是针对集合类的一个帮助类，他提供一系列静态方式实现对各种集合的搜索、排序、线程安全等操作。（例如：Collections.sort(list) //将list按从小到大排序） 8. Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况OOM与SOF 内存泄漏-程序在申请内存后，无法释放已申请的内存空间。内存泄漏堆积后的后果就是内存溢出 内存溢出-程序申请内存时，没有足够的内存供申请者使用 OOM：OutOfMemoryError 堆溢出 例如：队列添加的死循环 SOF：StackOverflowError 栈溢出 例如：方法的无限递归 9. Java面向对象的三个特征与含义封装是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布给其它对象。在java中能使用private、protected、public三种修饰符或不用（即默认defalut）对外部对象访问该对象的属性和行为进行限制。 继承是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。这非常类似大自然中的物种遗传。 多态从继承的定义，我们可以很清楚地知道有很多特殊的行为和属性的子类可能都属于某个大事物。但是这个大事物也有一个公共的行为可能与这些特殊的具体子类共有，只是每个具体的子类的行为可能各尽不同 （我们称之为重写，也是运行时多态）。还有一种可能就是这个子类拥有一个公共行为，但是这个子类可能会根据事实情况来做出不同的行为（我们称之为重载，也是编译时多态） 10. Override和Overload的含义和区别Override（覆盖、重写）和 Overload（重载）的区别： 重载和覆盖是 java 多态性的不同表现方式。 重载是在一个类中多态性的一种表现，是指在一个类中定义了多个同名的 方法，但是他们有不同的参数个数或有不同的参数类型。 在使用重载时要注意以下几点： ​ 1.重载只能通过不同的方法参数来区分。例如不同的参数类型，不同的 参数个数，不同的参数顺序。 ​ 2.不能通过访问权限、返回类型、抛出的异常进行重载。 覆盖是指子类函数覆盖父类中的函数。 在覆盖时要注意以下几点（重点！！）： ​ 1.覆盖的方法的函数名和参数必须要和被覆盖的方法的函数名和参数完全匹配，才能达到覆盖的效果； ​ 2.覆盖的方法的返回值必须和被覆盖的方法的返回值类型一致； ​ 3.覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者 是其子类； ​ 4.被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法， 并没有对其进行覆盖。 ​ 5. 子类函数的访问修饰权限要大于等于父类的 （public&gt;protected&gt;default&gt;private） 。（重要！！！） ​ 特别注意：Java 中，子类无法覆盖父类的 static 方法或 private 方法。 11. Static class与non static class的区别 static class non static class 1、用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用 1、非静态内部类需要持有对外部类的引用 2、内部静态类不需要有指向外部类的引用 2、非静态内部类能够访问外部类的静态和非静态成员 3、静态类只能访问外部类的静态成员，不能访问外部类的非静态成员 3、一个非静态内部类不能脱离外部类实体被创建 4、一个非静态内部类可以访问外部类的数据和方法 12. Java多态的实现原理多态的概念：同一操作作用于不同对象，可以有不同的解释，有不同的执行结果，这就是多态，简单来说就是：父类的引用指向之类对象。 多态的实现原理 13. 锁的等级：方法锁、对象锁、类锁方法锁和对象锁是同一个，所以只有方法锁或对象锁和类锁两个 方法锁、对象锁、类锁 14. ThreadLocal的设计理念与作用ThreadLocal设计理念 15. Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等1：特殊的队列：BlockingQueue，如果BlockingQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒，同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间时才会被唤醒继续操作。 2：BlockingQueue有四个具体的实现类， ArrayBlockingQueue：规定大小的BlockingQueue，其构造函数必须带一个int参数来指明其大小。其所含的对象是以FIFO（先入先出）顺序排序的。 LinkedBlockingQueue：大小不定的BlockingQueue，若其构造函数带一个规定大小的参数，生成的BlockingQueue有大小限制，若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定。其所含的对象是以FIFO顺序排序的。 PriorityBlockingQueue：类似于LinkedBlockingQueue,但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。 SynchronousQueue：特殊的BlockingQueue，对其的操作必须是放和取交替完成的。 3：semaphore：Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，acquire()获取一个许可，如果没有就等待，而release()释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 4：countdownLatch：CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。（当每个线程调用countdown方法直到将countdownlatch方法创建时数减为0时，那么之前调用await（）方法的线程才会继续执行。有一点注意，那就是只执行一次，不能到0以后重新执行） 5：CyclicBarrier：类有一个整数初始值，此值表示将在同一点同步的线程数量。当其中一个线程到达确定点，它会调用await() 方法来等待其他线程。当线程调用这个方法，CyclicBarrier阻塞线程进入休眠直到其他线程到达。当最后一个线程调用CyclicBarrier 类的await() 方法，它唤醒所有等待的线程并继续执行它们的任务。（当等待的线程数量达到CyclicBarrier线程指定的数量以后（调用await方法的线程数），才一起往下执行，否则大家都在等待，注意：如果达到指定的线程数量的时候：则可以重新计数，上面的过程可以循环） 6：CountDownLatch是减计数方式，计数==0时释放所有等待的线程；CyclicBarrier是加计数方式，计数达到构造方法中参数指定的值时释放所有等待的线程。 16. wait()和sleep()的区别1：wait()是Object类中，与notify和notifyAll搭配使用，sleep（）属于Thread类中的； 1.CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 2.CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 2：wait（）的时候放弃锁，而sleep的时候不放弃锁，但是在sleep的时候，可以调用interrupt（）函数来中断该线程； 3：suspend将当前线程挂起，要等到线程调用resume（）方法，该线程才能重新执行。 17. foreach与正常for循环效率对比1：foreach在使用的过程中，会创建额外的iterator方法，而每次调用哪个hasNext，和next（）方法，增加了更多的操作，对于访问数组的话for的效率要高于foreach；而且在foreach中，还要检查mod_count,避免导致快速失败，所以效率上会降低，但是由此可以看出foreach是线程安全的，而for不是线程安全的 2:什么时候使用：在多线程中，则使用foreach，如果是在方法中读局部变量的操作，则使用for。 18. Java IO与NIO1：javaIO与javaNIO区别：IO是基于流的，而NIO是基于缓存的。JavaIO每次从流中读取一个或者多个字节，知道读取所有的字节，不能前后移动流中的数据。而javaIO通过通道读取到缓存区中，需要可在缓存区中前后移动。 2：javaIO是阻塞的，而NIO是非阻塞的；IO阻塞当一个线程调用read（）方法或者write()方法的时候，该线程会阻塞直到数据读取或者写完毕，中间线程不能干别的事情；而在NIO中，以个线程可以通过通道去向缓存中发送一个读取数据请求，当没有数据时就会去做别的事，而不会一直等待直到读取到数据为止（io就是如果read了没有读取到想要的就会一直等待，直到读取到），NIO向文件缓存器写数据也一样，他可以只向其中写一部分，而不是全部写完（在写的时候线程当然不能做别的事情了）。 3：选择器：NIO允许一个线程来监视多个输入通道，可以注册一个选择器，然后用一个单独的线程来管理选择监控那一个通道； 4：运用场景：如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。 5：NIO的都流程：先向通道发出读取数据请求，然后通道向buffer中写入数据，如果buffer中满或者不满，你都可以向其中读取数据。 6：：同步异步：同步和异步是消息通信机制：同步：发出一个请求，然后一定要等待其返回，在返回期间，如果该线程去干别的事情，那就是不阻塞了（由于是同步，操作系统并不会通知你消息准备好了，所以你要过一会就去询问一次）；组合起来就叫同步非阻塞；如果在等待期间，当前线程一直在等待，而不干别的事情就是同步阻塞； 7：异步：发送一个请求，我（应用程序）就不用去管了，等待操作系统来完成以后通知我，如果在发送了请求以后，在操作系统没有通知我这段时间，线程什么都不干（所以异步阻塞基本上不实用），一直在哪儿等着，那么就是异步阻塞，如果在操作系统告诉应用程序之前，线程去干别的，也就是异步非阻塞； 8：同步阻塞的BIO、同步非阻塞的NIO(要去轮询，单独效率低比BIO稍低，但是在实际运用中效率就高了)、异步非阻塞的AIO； 9：NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。（回答的核心，服务器中应用） 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。 10：HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。（异步IO原理） 19. 反射的作用与原理Java反射：1、在运行状态中，对于任意一个类，都能够知道这个类的属性和方法 ​ 2、对于任意一个对象，都能够调用它的任何方法和属性 反射的作用：在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。 反射的原理：JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。 反射的实现主要借助以下四个类： Class：类的对象 Constructor：类的构造方法 Field：类中的属性对象 Method：类中的方法对象 20. 泛型常用特点，List&lt; String &gt;能否转为List&lt; Object &gt;泛型常用特点 21. 解析XML的几种方式的原理与特点：DOM、SAX、PULLJava解析xml的五种方式比较 22. Java与C++对比C++ 与Java差异总结 23. Java1.7与1.8新特性JDK1.7和1.8新特性梳理 24. 设计模式：单例、工厂、适配器、责任链、观察者等等Java设计模式]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识大纲]]></title>
    <url>%2Fvilce%2F2018%2F07%2F18%2Fmain%2F%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[重点知识1. JVM内存管理机制和垃圾回收机制（搞得透彻） 2. JVM内存调优（了解怎么回事，做项目中使用较多）3. 设计模式（熟悉常见设计模式的应用场景）4. 多线程（线程和进程、线程的状态、线程并发的操作等）5. JAVA集合类框架（理解框架图、HashMap、ArrayList、HashSet等的关系和区别，其中HashMap的存储机制很重要）6. JAVA的异常处理机制（异常的分类、常见的异常有哪些、Try catch finally的使用）7. JVM的运行机制（理解JVM是如何运行的）8. Linux基础（有一定需求，搭建Linux虚拟机，并练习常用的命令）数据结构和算法常见的排序算法需要理解其原理和会写代码，还有时间空间复杂度也要知道 队列、栈：需要理解其存取结构，并能在某些场景下使用 二叉树：树的遍历、树的深度、按层次输出、平衡二叉树、逆序打印树等 链表：逆序、合并两有序的链表、判断链表是否有环、链表倒数第K个元素等 字符串：KMP算法、动态规划（这个是重点，需要理解动态规划，常见的题有：求解最长回文子串，求解最长公子串等） 海量数据处理：Bit-map、分而治之、hash映射等 数据库相关最基本的数据库CRUD操作要熟悉，能够根据表写出需要的SQL语句 事务、零时表、索引、表锁、行列锁、视图、存储过程等都要深入理解 Nosql和redis等非关系数据库 开源框架像SSH等的开源框架在面试过程中问的很少，但是也是有必要了解SSH的运行原理和使用。面试主要考察的是基础，所以更加偏向于考察数据结构、算法、数据库、JAVA基础知识等。所以，如果你时间有限，可以把精力放在基础知识的学习和复习上，如果你时间充裕，可以学习和复习开源框架相关知识。对于开源框架：最好还是看看源码，对自己的好处是很大的。]]></content>
      <categories>
        <category>大纲</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合Redis实现缓存操作]]></title>
    <url>%2Fvilce%2F2018%2F07%2F08%2Fmain%2FSpringBoot%20%E6%95%B4%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 缓存的应用场景 什么是缓存？ 在大流量场景下，需要将一些经常展现和不会频繁变更的数据，存放在存取速率更快的地方。缓存就是一个存储器。Redis是一个高性能的key-value数据库。 缓存的应用场景有哪些？ 比如常见的电商场景，根据商品ID获取商品信息时，店铺信息和商品详情信息就可以缓存在Redis，直接从Redis获取。减少了去数据库查询的次数。但会出现新的问题，就是如何对缓存进行更新？ 2. 更新缓存的策略缓存更新的模式有四种：Cache aside，Read through，Write through，Write behind caching 这里我们使用的是Cache Aside策略，从三个方面： 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 大致流程如下： 获取商品详情举例 a. 从商品Cache中获取商品详情，如果存在，则返回获取Cache数据返回。 b. 如果不存在，则从商品DB中获取，获取成功后，将数据存到Cache中。则下次获取商品详情就可以从Cache中获取商品详情数据。 c. 从商品DB中更新或者删除商品详情成功后，则从缓存中删除对应商品的详情缓存。 3. 运行工程案例（1）数据库和Redis准备 (2)利用Redis进行数据存储读取 a.首先需要注意的是，对于实体类需要对象序列化后才存储到Redis中，所以实体类对象需要实现序列化，否则就会爆出下面的异常： 1java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.capsp.model.Language] 如果需要自定义序列化实现，只要实现RedisSerializer接口去实现即可，然后在使用RedisTemplate.setValueSerializer方法去设置你实现的序列化实现。 b.对于接口的业务逻辑实现类LanguageServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.capsp.service.Impl;import com.capsp.mapper.LanguageMapper;import com.capsp.model.Language;import com.capsp.service.LanguageService;import com.capsp.tools.LogUtils;import org.apache.log4j.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.ListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;@Service(value = &quot;LanguageServiceImpl&quot;)public class LanguageServiceImpl implements LanguageService&#123; private static Logger logger = Logger.getLogger(LogUtils.class); @Autowired private LanguageMapper languageMapper; @Autowired private RedisTemplate redisTemplate; //从缓存中获取信息，返回List public List&lt;Language&gt; getListFromRedis(String key)&#123; ListOperations&lt;String,Language&gt; operations = redisTemplate.opsForList(); List&lt;Language&gt; list = new ArrayList&lt;Language&gt;(); //判断缓存中是否存在 boolean hasKey = redisTemplate.hasKey(key); if (hasKey)&#123; //存在时，从缓存中获取信息，遍历获取，从第0位获取到倒数-1位的序列化后的对象 list = operations.range(key,0,-1); logger.info(&quot;从缓存中获取信息&gt;&gt;&quot;); return list; &#125; return null; &#125; @Override public List&lt;Language&gt; getAllLanguage() &#123; List&lt;Language&gt; list = new ArrayList&lt;Language&gt;(); String key = &quot;allLanguage&quot;; //从缓存中获取信息 list = getListFromRedis(key); if (list == null)&#123; //缓存不存在时 list = languageMapper.getAllLanguage(); //插入缓存 redisTemplate.opsForList().leftPushAll(key,list); //设置过期时间 redisTemplate.expire(key,1, TimeUnit.MINUTES); logger.info(&quot;信息存入缓存&gt;&gt;&quot;); &#125; return list; &#125;&#125; 首先这里注入了RedisTemplate对象。RedisTemplate封装了RedisConnection，具有连接功能，序列化和Redis操作等功能。还有针对Sting的支持对象StringRedisTemplata. Redis 操作视图接口类用的是 ValueOperations，对应的是 Redis String/Value 操作。还有其他的操作视图，ListOperations、SetOperations、ZSetOperations 和 HashOperations 。ValueOperations 插入缓存是可以设置失效时间，这里设置的失效时间是 1m。 对于一个接口访问两次，效果如下： 可以很明显的发现提速了近10倍。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Redis]]></title>
    <url>%2Fvilce%2F2018%2F06%2F28%2Fmain%2FSpringboot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[1.Redis概述 redis是一个开源的，先进的 key-value 存储可用于构建高性能的存储解决方案。它支持数据结构有字符串，哈希，列表，集合，带有范围查询的排序集，位图，超文本和具有半径查询的地理空间索引。 NoSQL，Not Only [SQL]，泛指非关系型的数据库。所以redis是一种nosql。敲黑板画重点：redis是一种nosql. redis的优点： 异常快速 支持丰富的数据类型 操作都是原子的 2.Redis下载安装linux系统下安装：$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz [] tarxzfredis−3.2.6.tar.gztarxzfredis−3.2.6.tar.gz cd redis-3.2.6 $ make 1234567启动服务器： $ src/redis-server 启动客户端 $ src/redis-climac下安装: brew install redis 启动： 12redis-serverredis-cli windows下安装：由于官方并没有提供windows 版本，不过微软为了能够应用redis 到 windows服务器，由微软维护了windows版的redis，下载地址：点击进入.建议下载msi 版本，直接安装即可。 根据电脑系统选择32位还是64位，安装后找到安装文件夹： 测试运行： 打开cmd窗口（管理员身份运行），使用命令切换到安装的文件夹下，然后运行 1redis-server.exe redis.windows.conf 可能出现如下问题： 解决方案：如下按顺序输入命令就可以了 12341. redis-cli.exe2. shutdown3. exit4. redis-server.exe redis.windows.conf （目的应该是删除上次redis错误启动，生成的aof、dump文件） 正常启动如下： 这时候另外开启一个cmd窗口，原来的窗口不要关闭，不然redis服务端就关闭了，就无法访问了。 还是一样的切到安装目录下，运行： 12345redis-cli.exe -h 127.0.0.1 -p 6379 设置键值对 set key 123取出键值对get key 问题：但这样执行redis-server.exe redis.windows.conf命令开启Redis服务不切合实际，应该设置在服务中启动。 安装成Windows服务-开机自启：打开cmd窗口（管理员身份运行），切换到安装目录下，运行： 1redis-server --service-install redis.windows.conf 出现成功安装，则表明已经作为windows服务了 : 打开cmd窗口输入services.msc，Redis出现在服务中，自行启动该服务. 3.Spingboot引入依赖：在pom文件中添加redis依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据源：123456789spring.redis.host=localhostspring.redis.port=6379#spring.redis.password=spring.redis.database=1spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1spring.redis.pool.max-idle=500spring.redis.pool.min-idle=0spring.redis.timeout=0 如果redis有密码，配置一下就可以了，现在就可以访问redis数据了。 数据访问层dao通过redisTemplate来访问redis 12345678910111213141516@Repositorypublic class RedisDao &#123; @Autowired private StringRedisTemplate template; public void setKey(String key,String value)&#123; ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期 &#125; public String getValue(String key)&#123; ValueOperations&lt;String, String&gt; ops = this.template.opsForValue(); return ops.get(key); &#125;&#125; 单元测试12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; public static Logger logger= LoggerFactory.getLogger(SpringbootRedisApplicationTests.class); @Test public void contextLoads() &#123; &#125; @Autowired RedisDao redisDao; @Test public void testRedis()&#123; redisDao.setKey(&quot;name&quot;,&quot;vilce&quot;); redisDao.setKey(&quot;age&quot;,&quot;11&quot;); logger.info(redisDao.getValue(&quot;name&quot;)); logger.info(redisDao.getValue(&quot;age&quot;)); &#125;&#125; 启动单元测试，可能出现如图错误： 此时是由于junit版本过低，将依赖版本改为4.12或更高就行了，继续运行出现： 这里断言工具Assert报错，发现SpringJUit4ClassRunner这个导入的工具类出错了，找到其导入依赖的包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 将其版本回退或者隐掉为默认。 再次启动单元测试，控制台打印： 单元测试通过。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger常用注解学习]]></title>
    <url>%2Fvilce%2F2018%2F06%2F13%2Fmain%2FSwagger%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[常用注解有： Api ApiModel ApiModelProperty ApiOperation ApiParam ApiResponse ApiResponses ResponseHeader 1. Api标记Api用在类上，说明该类的作用。可以标记一个Controller类作为Swagger文档资源，使用方法： 与Controller注解并列使用。 属性配置： 属性名称 备注 value url的路径值 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true 将在文档中隐藏 在SpringMvc中的配置如下： 效果如下： 2.ApiOperation标记ApiOperation：用在方法上，说明方法的作用，每一个url资源的定义，使用方法： 与Controller中的方法并列使用 属性配置： 属性名称 备注 value url的路径值 tags 如果设置这个值、value的值会被覆盖 description 对api资源的描述 basePath 基本路径可以不配置 position 如果配置多个Api 想改变显示的顺序位置 produces For example, “application/json, application/xml” consumes For example, “application/json, application/xml” protocols Possible values: http, https, ws, wss. authorizations 高级特性认证时配置 hidden 配置为true 将在文档中隐藏 response 返回的对象 responseContainer 这些对象是有效的 “List”, “Set” or “Map”.，其他无效 httpMethod “GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH” code http的状态码 默认 200 extensions 扩展属性 在SpringMvc中的配置如下： 效果如下： 3.ApiParam标记ApiParam请求属性，使用方法： 在Controller中的方法并列使用 属性配置： 属性名称 备注 name 属性名称 value 属性值 defaultValue 默认属性值 allowableValues 可以不配置 required 是否属性必填 access 不过多描述 allowMultiple 默认为false hidden 隐藏该属性 example 举例子 在SpringMvc中的配置如下： 效果如下： 4.ApiResponse和ApiResponses标记ApiResponse:响应配置，使用方式： 与Controller中的方法并列使用。 属性配置： 属性名称 备注 code http的状态码 message 描述 response 默认响应类 Void reference 参考ApiOperation中配置 responseHeaders 参考 ResponseHeader 属性配置说明 responseContainer 参考ApiOperation中配置 在SpringMvc中的配置如下： 效果如下： 5.ApiImplicitParam和ApiImplicitParams标记ApiImplicitParam:响应配置，使用方式： 与Controller中的方法并列使用。 属性配置： 属性名称 备注 name 参数名，对应方法中单独的参数名称 value 参数中文说明 required 是否必填 paramType 参数类型，取值为path, query, body, header, form dataType 参数数据类型 defaultValue 默认值 在SpringMvc中的配置如下： 效果如下： 6.ApiModel与ApiModelProperty标记ApiModel:响应配置，使用方式： 与Model注解并列使用。 ApiModelProperty响应配置，使用方式： 与Model中的属性并列使用。 属性配置： 属性名称 备注 value url的路径值 description 对api资源的描述 在SpringMvc中的配置如下： 效果如下： 7.其他 ApiOperation：用于方法，表示一个http请求的操作 。 Authorization：声明要在资源或操作上使用的授权方案 。 AuthorizationScope：介绍一个OAuth2授权范围。 ResponseHeader：响应头设置，使用方法。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC常用注解学习]]></title>
    <url>%2Fvilce%2F2018%2F06%2F05%2Fmain%2FSpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%40Controller%2C%40Service%2C%40Repository%2C%40Component%2F</url>
    <content type="text"><![CDATA[SpringMVC常用注解@Controller,@Service,@Repository,@Component@Controller @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法。通俗来说，被Controller标记的类就是一个控制器，这个类中的方法，就是相应的动作。 @RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。如上图的调用登录接口时路径就是：localhost:8080/xxx/user/login @Controller和@RestController的区别@RestController注解相当于@ResponseBody + @Controller合在一起的作用 1）如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 Internal Resource View Resolver 不起作用，返回的内容就是Return里面的内容 2）如果需要返回指定页面，则需要用@Controller配合视图解析器 Internal Resource View Resolver 才行。如果需要返回 JSON、XML 或自定义 media Type 内容到页面，则需要在对应的方法上加上@ResponseBody注解。 @Service @Service(value=”UserServiceImpl”)注解是告诉Spring，当Spring要创建UserServiceImpl的实例时，bean的名字必须叫做“UserServiceImpl”，这样当Action需要使用UserServiceImpl的实例时，就可以由Spring创建好的“UserServiceImpl”，然后注入给Action。 @Repository @Repository(value=”UserDaoImpl”)注解是告诉Spring，让Spring创建一个名字叫“UserDaoImpl”的UserDaoImpl实例。 当Service需要使用Spring创建的名字叫“UserDaoImpl”的UserDaoImpl实例时，就可以使用@Resource(name=”UserDaoImpl”)注解告诉Spring，Spring把创建好的UserDaoImpl注入给Service即可。 @Autowired可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作，@Autowired是根据类型进行自动装配的 @Component @Component定义Spring管理Bean 总结一下：@Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。分发处理器将会扫描使用了该注解的类的方法。通俗来说，被Controller标记的类就是一个控制器，这个类中的方法，就是相应的动作。 1、@Controller控制器（注入服务） 用于标注控制层，相当于struts中的action层 2、@Service服务（注入dao） 用于标注服务层，主要用来进行业务的逻辑处理 3、@Repository（实现dao访问） 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件。 4、@Component（把普通pojo实例化到spring容器中） 相当于配置文件中的 1&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; 泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Service等的时候），我们就可以使用@Component来标注这个类 说明： 1&lt;context:component-scan base-package=&quot;com.*&quot;&gt; 这个例子是引入Component组件的例子，其中base-package表示为需要扫描的所有子包。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis映射文件SQL语句学习(2)]]></title>
    <url>%2Fvilce%2F2018%2F05%2F31%2Fmain%2FSQL%E8%AF%AD%E5%8F%A5%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%882%EF%BC%89%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[SQL语句映射文件（2）增删改查、参数、缓存1. select一个select元素非常简单：12345678910&lt;!-- 查询学生，根据id --&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;String&quot; resultMap=&quot;studentResultMap&quot;&gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.CLASS_ID FROM STUDENT_TBL ST WHERE ST.STUDENT_ID = #&#123;studentID&#125; &lt;/select&gt; 这条语句就叫做 getStudent，有一个String参数，并返回一个StudentEntity类型的对象。 注意参数的标识是：#{studentID}。 select语句属性配置细节： 属性 描述 取值 默认 id 在这个模式下唯一的标识符，可被其它语句引用 parameterType 传给此语句的参数的完整类名或别名 resultType 语句返回值类型的整类名或别名。注意，如果是集合，那么这里填写的是集合的项的整类名或别名，而不是集合本身的类名。（resultType 与resultMap 不能并用 resultMap 引用的外部resultMap 名。结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。（resultType 与resultMap 不能并用） flushCache 如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false true\ false false useCache 如果设为true，则语句的结果集将被缓存。select 语句默认设为false true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 正整数 未设置 fetchSize 设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定 正整数 驱动器决定 statementType statement，preparedstatement，callablestatement。 预准备语句、可调用语句 STATEMENT PREPARED CALLABLE PREPARED resultSetType forward_only，scroll_sensitive，scroll_insensitive 只转发，滚动敏感，不区分大小写的滚动 FORWARD_ONLY SCROLL_SENSITIVE SCROLL_INSENSITIVE 驱动器决定 2.insert一个简单的insert语句： 12345678910111213&lt;!-- 插入学生 --&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;StudentEntity&quot;&gt; INSERT INTO STUDENT_TBL (STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, CLASS_ID) VALUES (#&#123;studentID&#125;, #&#123;studentName&#125;, #&#123;studentSex&#125;, #&#123;studentBirthday&#125;, #&#123;classEntity.classID&#125;) &lt;/insert&gt; insert可以使用数据库支持的自动生成主键策略，设置useGeneratedKeys=”true”，然后把keyProperty 设成对应的列，就搞定了。比如说上面的StudentEntity 使用auto-generated 为id 列生成主键. 还可以使用selectKey元素。下面例子，使用mysql数据库nextval(‘student’)为自定义函数，用来生成一个key。 12345678910111213141516&lt;!-- 插入学生 自动主键--&gt; &lt;insert id=&quot;insertStudentAutoKey&quot; parameterType=&quot;StudentEntity&quot;&gt; &lt;selectKey keyProperty=&quot;studentID&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&gt; select nextval(&apos;student&apos;) &lt;/selectKey&gt; INSERT INTO STUDENT_TBL (STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, CLASS_ID) VALUES (#&#123;studentID&#125;, #&#123;studentName&#125;, #&#123;studentSex&#125;, #&#123;studentBirthday&#125;, #&#123;classEntity.classID&#125;) &lt;/insert&gt; insert语句属性配置细节： 属性 描述 取值 默认 id 在这个模式下唯一的标识符，可被其它语句引用 parameterType 传给此语句的参数的完整类名或别名 flushCache 如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false true\ false false useCache 如果设为true，则语句的结果集将被缓存。select 语句默认设为false true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 正整数 未设置 fetchSize 设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定 正整数 驱动器决定 statementType statement，preparedstatement，callablestatement。 预准备语句、可调用语句 STATEMENT PREPARED CALLABLE PREPARED useGeneratedKeys 告诉MyBatis 使用JDBC 的getGeneratedKeys 方法来获取数据库自己生成的主键（MySQL、SQLSERVER 等关系型数据库会有自动生成的字段）。默认：false true\ false false keyProperty 标识一个将要被MyBatis 设置进getGeneratedKeys 的key 所返回的值，或者为insert 语句使用一个selectKey子元素。 selectKey语句属性配置细节： 属性 描述 取值 keyProperty selectKey 语句生成结果需要设置的属性。 resultType 生成结果类型，MyBatis 允许使用基本的数据类型，包括String 、int类型。 order 可以设成BEFORE 或者AFTER，如果设为BEFORE，那它会先选择主键，然后设置keyProperty，再执行insert语句；如果设为AFTER，它就先运行insert 语句再运行selectKey 语句，通常是insert 语句中内部调用数据库（像Oracle）内嵌的序列机制。 BEFORE AFTER statementType 像上面的那样， MyBatis 支持STATEMENT，PREPARED和CALLABLE 的语句形式， 对应Statement ，PreparedStatement 和CallableStatement 响应 STATEMENT PREPARED CALLABLE 3. update、delete一个简单的update: 123456789&lt;!-- 更新学生信息 --&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;StudentEntity&quot;&gt; UPDATE STUDENT_TBL SET STUDENT_TBL.STUDENT_NAME = #&#123;studentName&#125;, STUDENT_TBL.STUDENT_SEX = #&#123;studentSex&#125;, STUDENT_TBL.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;, STUDENT_TBL.CLASS_ID = #&#123;classEntity.classID&#125; WHERE STUDENT_TBL.STUDENT_ID = #&#123;studentID&#125;; &lt;/update&gt; 一个简单的delete： 1234&lt;!-- 删除学生 --&gt; &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;StudentEntity&quot;&gt; DELETE FROM STUDENT_TBL WHERE STUDENT_ID = #&#123;studentID&#125; &lt;/delete&gt; update、delete语句属性配置细节： 属性 描述 取值 默认 id 在这个模式下唯一的标识符，可被其它语句引用 parameterType 传给此语句的参数的完整类名或别名 flushCache 如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为false true\ false false useCache 如果设为true，则语句的结果集将被缓存。select 语句默认设为false true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 true\ false false timeout 设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定 正整数 未设置 fetchSize 设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定 正整数 驱动器决定 statementType statement，preparedstatement，callablestatement。 预准备语句、可调用语句 STATEMENT PREPARED CALLABLE PREPARED 4. sqlsql元素用来定义一个可以复用的SQL语句段，供其它语句调用。比如： 123456789&lt;!-- 复用sql语句 查询student表所有字段 --&gt; &lt;sql id=&quot;selectStudentAll&quot;&gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.CLASS_ID FROM STUDENT_TBL ST &lt;/sql&gt; 这样，在select的语句中就可以直接引用使用了，将上面select语句改成： 12345&lt;!-- 查询学生，根据id --&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;String&quot; resultMap=&quot;studentResultMap&quot;&gt; &lt;include refid=&quot;selectStudentAll&quot;/&gt; WHERE ST.STUDENT_ID = #&#123;studentID&#125; &lt;/select&gt; 5. parameters 上面很多地方已经用到了参数，比如查询、修改、删除的条件，插入，修改的数据等，MyBatis可以使用的基本数据类型和Java的复杂数据类型。​ 基本数据类型，String，int，date等。​ 但是使用基本数据类型，只能提供一个参数，所以需要使用Java实体类，或Map类型做参数类型。通过#{}可以直接得到其属性。 1）基本类型参数根据入学时间，检索学生列表： 123456&lt;!-- 查询学生list，根据入学时间 --&gt; &lt;select id=&quot;getStudentListByDate&quot; parameterType=&quot;Date&quot; resultMap=&quot;studentResultMap&quot;&gt; SELECT * FROM STUDENT_TBL ST LEFT JOIN CLASS_TBL CT ON ST.CLASS_ID = CT.CLASS_ID WHERE CT.CLASS_YEAR = #&#123;classYear&#125;; &lt;/select&gt; 1234List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListByClassYear(StringUtil.parse(&quot;2007-9-1&quot;)); for (StudentEntity entityTemp : studentList) &#123; System.out.println(entityTemp.toString()); &#125; 2）Java实体类型参数根据姓名和性别，检索学生列表。使用实体类做参数： 123456&lt;!-- 查询学生list，like姓名、=性别，参数entity类型 --&gt; &lt;select id=&quot;getStudentListWhereEntity&quot; parameterType=&quot;StudentEntity&quot; resultMap=&quot;studentResultMap&quot;&gt; SELECT * from STUDENT_TBL ST WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT(&apos;%&apos;, #&#123;studentName&#125;),&apos;%&apos;) AND ST.STUDENT_SEX = #&#123;studentSex&#125; &lt;/select&gt; 1234567StudentEntity entity = new StudentEntity(); entity.setStudentName(&quot;李&quot;); entity.setStudentSex(&quot;男&quot;); List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereEntity(entity); for (StudentEntity entityTemp : studentList) &#123; System.out.println(entityTemp.toString()); &#125; 3）Map参数根据姓名和性别，检索学生列表。使用Map做参数： 123456&lt;!-- 查询学生list，=性别，参数map类型 --&gt; &lt;select id=&quot;getStudentListWhereMap&quot; parameterType=&quot;Map&quot; resultMap=&quot;studentResultMap&quot;&gt; SELECT * from STUDENT_TBL ST WHERE ST.STUDENT_SEX = #&#123;sex&#125; AND ST.STUDENT_SEX = #&#123;sex&#125; &lt;/select&gt; 1234567Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;sex&quot;, &quot;女&quot;); map.put(&quot;name&quot;, &quot;李&quot;); List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereMap(map); for (StudentEntity entityTemp : studentList) &#123; System.out.println(entityTemp.toString()); &#125; 4）多参数的实现如果想传入多个参数，则需要在接口的参数上添加@Param注解： 接口写法： 1public List&lt;StudentEntity&gt; getStudentListWhereParam(@Param(value = &quot;name&quot;) String name, @Param(value = &quot;sex&quot;) String sex, @Param(value = &quot;birthday&quot;) Date birthdar, @Param(value = &quot;classEntity&quot;) ClassEntity classEntity); SQL写法： 123456789101112131415161718&lt;!-- 查询学生list，like姓名、=性别、=生日、=班级，多参数方式 --&gt; &lt;select id=&quot;getStudentListWhereParam&quot; resultMap=&quot;studentResultMap&quot;&gt; SELECT * from STUDENT_TBL ST &lt;where&gt; &lt;if test=&quot;name!=null and name!=&apos;&apos; &quot;&gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(&apos;%&apos;, #&#123;name&#125;),&apos;%&apos;) &lt;/if&gt; &lt;if test=&quot;sex!= null and sex!= &apos;&apos; &quot;&gt; AND ST.STUDENT_SEX = #&#123;sex&#125; &lt;/if&gt; &lt;if test=&quot;birthday!=null&quot;&gt; AND ST.STUDENT_BIRTHDAY = #&#123;birthday&#125; &lt;/if&gt; &lt;if test=&quot;classEntity!=null and classEntity.classID !=null and classEntity.classID!=&apos;&apos; &quot;&gt; AND ST.CLASS_ID = #&#123;classEntity.classID&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 进行查询： 1234List&lt;StudentEntity&gt; studentList = studentMapper.getStudentListWhereParam(&quot;&quot;, &quot;&quot;,StringUtil.parse(&quot;1985-05-28&quot;), classMapper.getClassByID(&quot;20000002&quot;)); for (StudentEntity entityTemp : studentList) &#123; System.out.println(entityTemp.toString()); &#125; 5）字符串代入法​ 默认的情况下，使用#{}语法会促使MyBatis 生成PreparedStatement 属性并且使用PreparedStatement 的参数（=？）来安全的设置值。尽量这些是快捷安全，也是经常使用的。但有时候你可能想直接未更改的字符串代入到SQL 语句中。比如说，对于ORDER BY，你可能会这样使用：ORDER BY ${columnName}但MyBatis 不会修改和规避掉这个字符串。 注意：这样地接收和应用一个用户输入到未更改的语句中，是非常不安全的。这会让用户能植入破坏代码，所以，要么要求字段不要允许客户输入，要么你直接来检测他的合法性 。 6. cache缓存MyBatis 包含一个强在的、可配置、可定制的缓存机制。MyBatis 3 的缓存实现有了许多改进，既强劲也更容易配置。默认的情况，缓存是没有开启，除了会话缓存以外，它可以提高性能，且能解决全局依赖。开启二级缓存，你只需要在SQL 映射文件中加入简单的一行： 这句简单的语句的作用如下： 所有在映射文件里的select 语句都将被缓存。 所有在映射文件里insert,update 和delete 语句会清空缓存。 缓存使用“最近很少使用”算法来回收 缓存不会被设定的时间所清空。 每个缓存可以存储1024 个列表或对象的引用（不管查询出来的结果是什么）。 缓存将作为“读/写”缓存，意味着获取的对象不是共享的且对调用者是安全的。不会有其它的调用 者或线程潜在修改。 例如，创建一个FIFO 缓存让60 秒就清空一次，存储512 个对象结果或列表引用，并且返回的结果是只读。因为在不用的线程里的两个调用者修改它们可能会导致引用冲突。12&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;&gt; &lt;/cache&gt; 还可以在不同的命名空间里共享同一个缓存配置或者实例。在这种情况下，你就可以使用cache-ref 来引用另外一个缓存。 1&lt;cache-ref namespace=&quot;com.liming.manager.data.StudentMapper&quot;/&gt; Cache 语句属性配置细节： 属性 说明 取值 默认值 eviction 缓存策略： LRU - 最近最少使用法：移出最近较长周期内都没有被使用的对象 FIFI- 先进先出：移出队列里较早的对象 SOFT - 软引用：基于软引用规则，使用垃圾回收机制来移出对象 WEAK - 弱引用：基于弱引用规则，使用垃圾回收机制来强制性地移出对象 LRU FIFI SOFT WEAK LRU flushInterval 代表一个合理的毫秒总计时间。默认是不设置，因此使用无间隔清空即只能调用语句来清空 正整数 不设置 size 缓存的对象的大小 正整数 1024 readOnly 只读缓存将对所有调用者返回同一个实例。因此都不能被修改，这可以极大的提高性能。可写的缓存将通过序列 true\ false false]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis映射文件SQL语句学习(1)]]></title>
    <url>%2Fvilce%2F2018%2F05%2F30%2Fmain%2FSQL%E8%AF%AD%E5%8F%A5%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%881%EF%BC%89resultMap%2F</url>
    <content type="text"><![CDATA[SQL语句映射文件（1）resultMapSQL映射XML文件一些初级的元素： 1.cache - 配置给定模式的缓存 2.cache-ref - 从别的模式中引用一个缓存 3.resultMap - 这是最复杂而却强大的一个元素了，它描述如何从结果集中加载对象 4.sql - 一个可以被其他语句复用的SQL块 5.insert - 映射INSERT语句 6.update - 映射UPDATE语句 7.delete - 映射DELETE语句 8.select - 映射SELECT语句 一. resultMap​ resultMap是MyBatis中最重要最强大的元素了。可以让你比使用JDBC调用结果集省掉90%的代码，也可以让你做许多JDBC不支持的事。现实上，要写一个等同类似于交互的映射这样的复杂语句，可能要上千行的代码。ResultMap的目的就是这样简单的语句而不需要多余的结果映射，更多复杂的语句，除了只要一些绝对必须的语句描述关系以外，再也不需要其它的。 resultMap属性：type为java实体类；id为此resultMap的标识resultMap可以设置的映射： 1.constructor - 用来将结果反射给一个实例化好的类的构造器 a) idArg - ID 参数；将结果集标记为ID，以方便全局调用 b) arg - 反射到构造器的通常结果 2.id - ID 结果，将结果集标记为ID，以方便全局调用 3.result - 反射到JavaBean属性的普通结果 4.association - 复杂类型的结合；多个结果合成的类型​ a) nested result mappings - 几个resultMap自身嵌套关联，也可以引用到一个其它上 5.collection - 复杂类型集合 a collection of complex types 6.nested result mappings - resultMap的集合，也可以引用到一个其它上 7.discriminator - 使用一个结果值以决定使用哪个resultMap​ a) case - 基本一些值的结果映射的case情形​ i. nested result mappings - 一个case情形本身就是一个结果映射，因此也可以包括一些相同的元素，也可以引用一个外部resultMap. （1）id 、result id、result是最简单的映射，id为主键映射；result其他基本数据库表字段实体类属性的映射。 最简单的例子： 1234567&lt;resultMap type=&quot;com.capsp.model.Student&quot; id=&quot;studentResultMap&quot;&gt; &lt;id property=&quot;studentId&quot; column=&quot;STUDENT_ID&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;studentName&quot; column=&quot;STUDENT_NAME&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;studentSex&quot; column=&quot;STUDENT_SEX&quot; javaType=&quot;int&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;studentBirthday&quot; column=&quot;STUDENT_BIRTHDAY&quot; javaType=&quot;Date&quot; jdbcType=&quot;DATE&quot;/&gt; &lt;result property=&quot;studentPhoto&quot; column=&quot;STUDENT_PHOTO&quot; javaType=&quot;byte[]&quot; jdbcType=&quot;BLOB&quot; typeHandler=&quot;org.apache.ibatis.type.BlobTypeHandler&quot; /&gt; &lt;/resultMap&gt; id、result语句属性配置细节： 属性 描述 property 需要映射到JavaBean的属性名称 column 数据表的列名或者标签名 javaType 一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis通常会自行检测到。然后，如果你是要映射到一个HashMap，那你需要指定javaType要达到的目的 jdbcType 数据表支持的类型列表。这个属性只在insert、update或delete的时候针对允许空的列有用。JDBC需要这项，但MyBatis不需要。如果你是直接针对JDBC编码，且有允许空的列，而你要指定这项 typeHandler 使用这个属性可以覆写类型处理器。这项值可以是一个完整的类名，也可以是一个类型别名 支持的JDBC类型 ​ 为了将来的引用，MyBatis支持下列JDBC类型，通过JdbcType枚举： BIT，FLOAT，CHAR，TIMESTAMP，OTHER，UNDEFINED，TINYINT，REAL，VARCHAR，BINARY，BLOB，NVARCHAR，SMALLINT，DOUBLE，LONGVARCHAR，VARBINARY，CLOB，NCHAR，INTEGER，NUMERIC，DATE，LONGVARBINARY，BOOLEAN，NCLOB，BIGINT，DECIMAL，TIME，NULL，CURSOR （2）constructor​ 我们使用id、result时候，需要定义java实体类的属性映射到数据库表的字段上。这时候是使用JavaBean实现的。当然我们也可以使用实体类的构造方法来实现值的映射，这个时候是通过构造方法参数的书写的顺序来进行幅值的。 ​ 使用constructor功能有限（例如使用collection级联查询）。 ​ 上面使用id、result实现的功能就可以改成： 12345678&lt;resultMap type=&quot;StudentEntity&quot; id=&quot;studentResultMap&quot; &gt; &lt;constructor&gt; &lt;idArg javaType=&quot;String&quot; column=&quot;STUDENT_ID&quot;/&gt; &lt;arg javaType=&quot;String&quot; column=&quot;STUDENT_NAME&quot;/&gt; &lt;arg javaType=&quot;String&quot; column=&quot;STUDENT_SEX&quot;/&gt; &lt;arg javaType=&quot;Date&quot; column=&quot;STUDENT_BIRTHDAY&quot;/&gt; &lt;/constructor&gt; &lt;/resultMap&gt; ​ 当然，我们需要定义StudentEntity实体类的构造方法： 123456public StudentEntity(String studentID, String studentName, String studentSex, Date studentBirthday)&#123; this.studentID = studentID; this.studentName = studentName; this.studentSex = studentSex; this.studentBirthday = studentBirthday; &#125; （3）association联合联合元素用来处理“一对一”的关系。需要指定映射的Java实体类的属性，属性的javaType（通常MyBatis 自己会识别）。对应的数据库表的列名称。如果想覆写的话返回结果的值，需要指定typeHandler。 不同情况需要告诉MyBatis 如何加载一个联合。MyBatis 可以用两种方式加载： select: 执行一个其它映射的SQL 语句返回一个Java实体类型。较灵活； resultsMap: 使用一个嵌套的结果映射来处理通过join查询结果集，映射成Java实体类型。 例如，一个班级对应一个班主任。 首先定义好班级中的班主任属性： 1private TeacherEntity teacherEntity; a. 使用select实现联合例：班级实体类中有班主任的属性，通过联合在得到一个班级实体时，同时映射出班主任实体。 这样可以直接复用在TeacherMapper.xml文件中定义好的查询teacher根据其ID的select语句。而且不需要修改写好的SQL语句，只需要直接修改resultMap即可。 ClassMapper.xml文件部分内容： 1234567891011&lt;resultMap type=&quot;ClassEntity&quot; id=&quot;classResultMap&quot;&gt; &lt;id property=&quot;classID&quot; column=&quot;CLASS_ID&quot; /&gt; &lt;result property=&quot;className&quot; column=&quot;CLASS_NAME&quot; /&gt; &lt;result property=&quot;classYear&quot; column=&quot;CLASS_YEAR&quot; /&gt; &lt;association property=&quot;teacherEntity&quot; column=&quot;TEACHER_ID&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getClassByID&quot; parameterType=&quot;String&quot; resultMap=&quot;classResultMap&quot;&gt; SELECT * FROM CLASS_TBL CT WHERE CT.CLASS_ID = #&#123;classID&#125;; &lt;/select&gt; TeacherMapper.xml文件部分内容： 1234567891011121314&lt;resultMap type=&quot;TeacherEntity&quot; id=&quot;teacherResultMap&quot;&gt; &lt;id property=&quot;teacherID&quot; column=&quot;TEACHER_ID&quot; /&gt; &lt;result property=&quot;teacherName&quot; column=&quot;TEACHER_NAME&quot; /&gt; &lt;result property=&quot;teacherSex&quot; column=&quot;TEACHER_SEX&quot; /&gt; &lt;result property=&quot;teacherBirthday&quot; column=&quot;TEACHER_BIRTHDAY&quot;/&gt; &lt;result property=&quot;workDate&quot; column=&quot;WORK_DATE&quot;/&gt; &lt;result property=&quot;professional&quot; column=&quot;PROFESSIONAL&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTeacher&quot; parameterType=&quot;String&quot; resultMap=&quot;teacherResultMap&quot;&gt; SELECT * FROM TEACHER_TBL TT WHERE TT.TEACHER_ID = #&#123;teacherID&#125; &lt;/select&gt; b. 使用resultMap实现联合与上面同样的功能，查询班级，同时查询器班主任。需在association中添加resultMap（在teacher的xml文件中定义好的），新写sql（查询班级表left join教师表），不需要teacher的select。 修改ClassMapper.xml文件部分内容： 123456789101112&lt;resultMap type=&quot;ClassEntity&quot; id=&quot;classResultMap&quot;&gt; &lt;id property=&quot;classID&quot; column=&quot;CLASS_ID&quot; /&gt; &lt;result property=&quot;className&quot; column=&quot;CLASS_NAME&quot; /&gt; &lt;result property=&quot;classYear&quot; column=&quot;CLASS_YEAR&quot; /&gt; &lt;association property=&quot;teacherEntity&quot; column=&quot;TEACHER_ID&quot; resultMap=&quot;teacherResultMap&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getClassAndTeacher&quot; parameterType=&quot;String&quot; resultMap=&quot;classResultMap&quot;&gt; SELECT * FROM CLASS_TBL CT LEFT JOIN TEACHER_TBL TT ON CT.TEACHER_ID = TT.TEACHER_ID WHERE CT.CLASS_ID = #&#123;classID&#125;; &lt;/select&gt; （4）collection聚集聚集元素用来处理“一对多”的关系。需要指定映射的Java实体类的属性，属性的javaType（一般为ArrayList）；列表中对象的类型ofType（Java实体类）；对应的数据库表的列名称； 不同情况需要告诉MyBatis 如何加载一个聚集。MyBatis 可以用两种方式加载： select: 执行一个其它映射的SQL 语句返回一个Java实体类型。较灵活； resultsMap: 使用一个嵌套的结果映射来处理通过join查询结果集，映射成Java实体类型。 例如，一个班级有多个学生。 首先定义班级中的学生列表属性： 1private List&lt;StudentEntity&gt; studentList; a. 使用select实现聚集用法和联合很类似，区别在于，这是一对多，所以一般映射过来的都是列表。所以这里需要定义javaType为ArrayList，还需要定义列表中对象的类型ofType，以及必须设置的select的语句名称（需要注意的是，这里的查询student的select语句条件必须是外键classID）。 ClassMapper.xml文件部分内容： 123456789101112&lt;resultMap type=&quot;ClassEntity&quot; id=&quot;classResultMap&quot;&gt; &lt;id property=&quot;classID&quot; column=&quot;CLASS_ID&quot; /&gt; &lt;result property=&quot;className&quot; column=&quot;CLASS_NAME&quot; /&gt; &lt;result property=&quot;classYear&quot; column=&quot;CLASS_YEAR&quot; /&gt; &lt;association property=&quot;teacherEntity&quot; column=&quot;TEACHER_ID&quot; select=&quot;getTeacher&quot;/&gt; &lt;collection property=&quot;studentList&quot; column=&quot;CLASS_ID&quot; javaType=&quot;ArrayList&quot; ofType=&quot;StudentEntity&quot; select=&quot;getStudentByClassID&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getClassByID&quot; parameterType=&quot;String&quot; resultMap=&quot;classResultMap&quot;&gt; SELECT * FROM CLASS_TBL CT WHERE CT.CLASS_ID = #&#123;classID&#125;; &lt;/select&gt; StudentMapper.xml文件部分内容： 12345678910111213&lt;!-- java属性，数据库表字段之间的映射定义 --&gt; &lt;resultMap type=&quot;StudentEntity&quot; id=&quot;studentResultMap&quot;&gt; &lt;id property=&quot;studentID&quot; column=&quot;STUDENT_ID&quot; /&gt; &lt;result property=&quot;studentName&quot; column=&quot;STUDENT_NAME&quot; /&gt; &lt;result property=&quot;studentSex&quot; column=&quot;STUDENT_SEX&quot; /&gt; &lt;result property=&quot;studentBirthday&quot; column=&quot;STUDENT_BIRTHDAY&quot; /&gt; &lt;/resultMap&gt; &lt;!-- 查询学生list，根据班级id --&gt; &lt;select id=&quot;getStudentByClassID&quot; parameterType=&quot;String&quot; resultMap=&quot;studentResultMap&quot;&gt; &lt;include refid=&quot;selectStudentAll&quot; /&gt; WHERE ST.CLASS_ID = #&#123;classID&#125; &lt;/select&gt; b. 使用resultMap实现聚集使用resultMap，就需要重写一个sql，left join学生表 1234567891011121314151617&lt;resultMap type=&quot;ClassEntity&quot; id=&quot;classResultMap&quot;&gt; &lt;id property=&quot;classID&quot; column=&quot;CLASS_ID&quot; /&gt; &lt;result property=&quot;className&quot; column=&quot;CLASS_NAME&quot; /&gt; &lt;result property=&quot;classYear&quot; column=&quot;CLASS_YEAR&quot; /&gt; &lt;association property=&quot;teacherEntity&quot; column=&quot;TEACHER_ID&quot; resultMap=&quot;teacherResultMap&quot;/&gt; &lt;collection property=&quot;studentList&quot; column=&quot;CLASS_ID&quot; javaType=&quot;ArrayList&quot; ofType=&quot;StudentEntity&quot; resultMap=&quot;studentResultMap&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getClassAndTeacherStudent&quot; parameterType=&quot;String&quot; resultMap=&quot;classResultMap&quot;&gt; SELECT * FROM CLASS_TBL CT LEFT JOIN STUDENT_TBL ST ON CT.CLASS_ID = ST.CLASS_ID LEFT JOIN TEACHER_TBL TT ON CT.TEACHER_ID = TT.TEACHER_ID WHERE CT.CLASS_ID = #&#123;classID&#125;; &lt;/select&gt; （5）discriminator鉴别器有时一个单独的数据库查询也许返回很多不同（但是希望有些关联）数据类型的结果集。鉴别器元素就是被设计来处理这个情况的，还有包括类的继承层次结构。鉴别器非常容易理解，因为它的表现很像Java语言中的switch语句。 定义鉴别器指定了column和javaType属性。列是MyBatis查找比较值的地方。JavaType是需要被用来保证等价测试的合适类型（尽管字符串在很多情形下都会有用）。 下面这个例子为，当classId为20000001时，才映射classId属性。 12345678910111213&lt;resultMap type=&quot;liming.student.manager.data.model.StudentEntity&quot; id=&quot;resultMap_studentEntity_discriminator&quot;&gt; &lt;id property=&quot;studentId&quot; column=&quot;STUDENT_ID&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;studentName&quot; column=&quot;STUDENT_NAME&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result property=&quot;studentSex&quot; column=&quot;STUDENT_SEX&quot; javaType=&quot;int&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result property=&quot;studentBirthday&quot; column=&quot;STUDENT_BIRTHDAY&quot; javaType=&quot;Date&quot; jdbcType=&quot;DATE&quot;/&gt; &lt;result property=&quot;studentPhoto&quot; column=&quot;STUDENT_PHOTO&quot; javaType=&quot;byte[]&quot; jdbcType=&quot;BLOB&quot; typeHandler=&quot;org.apache.ibatis.type.BlobTypeHandler&quot; /&gt; &lt;result property=&quot;placeId&quot; column=&quot;PLACE_ID&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;discriminator column=&quot;CLASS_ID&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;&gt; &lt;case value=&quot;20000001&quot; resultType=&quot;liming.student.manager.data.model.StudentEntity&quot; &gt; &lt;result property=&quot;classId&quot; column=&quot;CLASS_ID&quot; javaType=&quot;String&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot搭建]]></title>
    <url>%2Fvilce%2F2018%2F05%2F09%2Fmain%2FSpringBoot%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[需要： 15分钟 jdk 1.8以上 maven 3.0+ idea 打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。 pom文件为基本的依赖管理文件 resouces资源文件 statics静态资源 templates模版资源 application.properties配置文件 SpringbootApplication程序的入口 功能演示创建一个controller： 注意这里的controller文件要么与Application程序同级要么放在其下级文件夹内。启动SpringbootApplication的main方法，打开浏览器localhost:8080，浏览器显示：神奇之处： 没有做任何的web.xml配置 没有做任何的spring nvc的配置;springboot为你做了 没有配置tomcat;springboot内嵌tomcat 启动Springboot方式：1. IDE 运行Applciation这个类的main方法： 2. 在springboot的应用的根目录下运行mvn spring-boot:run 3. 使用mvn install 生成 jar 后运行1234先到项目根目录mvn installcd targetjava -jar XXXX.jar （将项目打包成 jar 包，还可以直接用IDE进行项目打包。过程如下图） (每次重新部署时一定要重新打包)Spring Boot配置文件详解在现实的开发环境中，我们需要不同的配置环境；格式为application-{profile}.propreties,其中{profile}对应你的环境标识，比如： application-test.properties: 测试环境 application-dev.properties: 开发环境 application-prod.properties: 生产环境 这里可以将后缀改为.yml，两种文件格式都支持如何使用？只需要我们在application.yml中加：123spring: profiles: active: dev 其中application-dev.yml:12server: port: 8082 启动工程，发现程序的端口不再是8080，而是8082。（启动出错，如果修改配置文件之前可以启动，先检查配置时是否留有空格，再检查该端口是否被占用）SpringBoot用JdbcTemplates访问Mysql1. 在创建项目的时候，不光勾上web，还可以勾上MySQL和JDBC。引入依赖后必须先配置连接MySQL的配置文件成功连接数据库，不然项目会启动失败。 2. 也可以在项目创建后在pom文件引入spring-boot-start-jdbc的依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 引入mysql连接类和连接池：1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 配置相关文件在application.yml文件配置mysql的驱动类，数据库地址，数据库帐号，密码信息。 这样springboot就可以访问数据库类了。SpringBoot的优缺点优点（1）快速构建项目（2）对主流开发框架的无配置集成（3）项目可独立运行，无须外部依赖Servlet容器（4）提供运行时的应用监控（5）极大地提高了开发、部署效率（6）与云计算的天然集成缺点（1）书籍文档较少且不够深入（2）发展很快，版本更迭很快]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2Fvilce%2F2018%2F04%2F27%2Fmain%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1.环境准备 node.js:因为 hexo 整个博客框架是基于node.js的，所以必须安装node.js环境。我安装的是最新的版本，v4.5.0，安装过程一路 next 即可。 git客户端:用来将hexo相关文件提交到github上去，安装过程一路next。 2.安装hexo框架环境准备好以后，我们便可以安装hexo博客框架。首先在本地磁盘中建立一个文件夹用来存放本地文件（可用于保存以及测试使用）！注意：强烈建议不要选择需要管理员权限才能创建文件（夹）的文件夹 然后在文件夹中右键打开git命令框 在git命令框中安装Hexo(npm install -g hexo) 初始化（hexo init） 安装相关的依赖包（npm install） 此时文件夹如下图 _config.yml：用来配置站点信息，大多数配置都在这里进行。 package.json：管理我们安装的一些插件，我们要删除某些插件的时候，可以在这里进行。 scaffolds：模板文件夹。 source：源文件夹是存放用户资源的地方,他下面有一个_posts，文件夹，我们发表的文件就存放在这个文件夹下。 themes：主题文件夹，Hexo 会根据主题来生成静态页面。 接下来在文件夹下执行 hexo g hexo s 然后用浏览器访问http://localhost:4000，就能看到hexo初始化界面。 3.部署微博到github 已有帐号的暂时忽略这一步，传送门: github，没有的话就老老实实创建一个吧。 创建仓库 部署文件到github 这里在上次文件代码时最好用ssh地址，需要为帐号配置ssh密钥，已经配置好的请忽略这一步。 找到文件夹下的_config.yml 文件，找到关键字 deploy ，然后修改成如下，我就用我自己的做示例：1234deploy: type: git repository: git@github.com:villce/vilce.git branch: master 执行一下命令部署项目到github hexo g hexo d 但是输入hexo d 可能会报 ERROR Deployer not fount： git 错误,这是因为没有安装hexo-deployer-git这个模块，无法识别该指令，安装该模块即可，输入如下命令： npm install hexo-deployer-git –save 浏览器输入villce.github.io/vilce即可访问,但可能出现图中情况，没有加载css样式。 更改一下_config.yml文件，其中的url和root属性url: https://villce.github.io root: /vilce/ root下面应该设置成 /项目名 ,而不是 /4.参考 http://www.leeyom.top/2016/09/25/tech-hexo-github/ https://www.jianshu.com/p/e99ed60390a8 https://blog.csdn.net/nathan1987_/article/details/50322493]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
